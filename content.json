[{"title":"dubbo扩展点","date":"2020-01-11T16:23:25.855Z","path":"2020/01/12/dubbo扩展点/","text":"Dubbo扩展点加载机制1、Java SPI使用了策略模式，一个接口多种实现。只声明接口，具体的实现由程序之外的配置控制，用于具体实现的装配。 具体步骤如下： （1）定义一个接口以及对应的方法 （2）编写接口的实现类 （3）在META-INF/services/ 目录下，创建一个接口全限定名命名的文件 （4）文件内容为具体实现类的全限定名，如果有多个，则用分行符分隔 （5）在代码中通过java.util.ServiceLoader 来加载具体的实现类 2、扩展点加载机制的改进 初始化 JDK SPI: 一次性实例化扩展点所有实现，初始化耗时，没有也加载浪费资源 Dubbo SPI: 加载配置文件中的类，并分为不同的种类缓存在内存中，不会立即全部初始化 扩展点加载失败 JDK SPI: 获取不到扩展的名称，不能打印正常的异常信息 Dubbo SPI: 抛出真实异常并打印日志，部分扩展点加载失败不会影响其他扩展点和整个框架的使用 实现了IOC和AOP机制 3、扩展点的配置规范 规范名 规范说明 SPI配置文件路径 META-INF/services/、META-INF/dubbo/、META-INF/dubbo/internal/ 全路径类名 文件内容格式 key=value方式，多个用换行符分隔 4、扩展点的分类与缓存Dubbo SPI Class缓存：Dubbo SPI获取扩展类时，先从缓存中读取。如果缓存中不存在，则加载配置文件，根据配置把Class缓存到内存中，不会直接初始化 实例缓存：基于性能考虑，Dubbo框架不仅会缓存Class，也会缓存Class实例化对象。先从缓存中读取，如果缓存中不存在，则重新加载并缓存起来，按需实例化并缓存 扩展类种类 普通扩展类 包装扩展类：Wrapper类没有具体的实现，只是做了通用逻辑的抽象，在构造方法中传入一个具体的扩展接口的实现 自适应扩展类：一个扩展接口有多种实现类，具体实现哪个实现类可以不写死在配置或代码中，在运行时，通过传入URL中的某些参数动态来确定。自适应特性@Adaptive 其他缓存 自适应和自动激活的区别？ isAssignableFrom 和 instanceof 的区别？ 123父类.class.isAssignableFrom(子类.class)子类实例 instanceof 父类类型","tags":[]}]