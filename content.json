{"meta":{"title":"linjunhua's Blog","subtitle":"","description":"","author":"linlinnn","url":"https://github.com/linlinnn","root":"/"},"pages":[{"title":"Tags","date":"2020-01-19T16:29:03.090Z","updated":"2020-01-19T16:29:03.090Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/linlinnn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-11T14:37:31.000Z","updated":"2020-01-11T14:37:31.921Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/linlinnn/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2020-01-18T12:56:07.352Z","updated":"2020-01-18T12:56:07.352Z","comments":true,"path":"about/index.html","permalink":"https://github.com/linlinnn/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2020-01-18T12:56:07.380Z","updated":"2020-01-18T12:56:07.380Z","comments":true,"path":"project/index.html","permalink":"https://github.com/linlinnn/project/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2020-02-26T02:34:10.000Z","updated":"2020-02-26T02:34:10.337Z","comments":true,"path":"2020/02/26/test/","link":"","permalink":"https://github.com/linlinnn/2020/02/26/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java源码之ArrayList","slug":"Java源码之ArrayList","date":"2020-02-25T01:14:10.654Z","updated":"2020-02-26T02:14:01.462Z","comments":true,"path":"2020/02/25/Java源码之ArrayList/","link":"","permalink":"https://github.com/linlinnn/2020/02/25/Java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/","excerpt":"","text":"Java源码之ArrayList1、带着问题看源码Q1：添加、查找、遍历操作最为普遍，相应操作的原理是什么，时间复杂度是多少？ Q2：如何进行动态扩展的？ Q3：序列化机制是怎样的？ 2、数据存储结构ArrayList在日常工作中非常常用，底层结构就是一个数组 12345678private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; // non-private to simplify nested class accessprivate int size; 1、DEFAULT_CAPACITY，初始大小为10 2、EMPTY_ELEMENTDATA 和DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的区别在于添加第一个元素时的扩容策略 3、elementData使用transient修饰，比如一个100万大小的数组，只存储了100个数据，那么只序列化这100个就好了，避免浪费不必要的资源，使用writeObject和readObject进行序列化 3、初始化有三种初始化方法：指定大小初始化，无参初始化，指定数据集合初始化 12345678910111213141516171819202122232425262728293031public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 创建一个指定大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 返回静态的空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 初始大小为负数，抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;public ArrayList() &#123; // 返回静态的空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在添加第一个元素后大小才为10 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 如果集合元素类型不是Object，转换成Object类型，Q4：为什么？ if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 返回静态的空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; Q4的测试代码如下，转换是为了防止数组元素赋值时发生类型错误 123456List&lt;String&gt; list = Arrays.asList(\"hello,ArrayList\");Object[] arr = list.toArray();System.out.println(arr.getClass().getSimpleName()); // String[]arr[0] = new Object();// java.lang.ArrayStoreException 4、添加元素1234567891011121314151617181920212223242526272829303132333435363738public boolean add(E e) &#123; // 确保数组容量大小，不够时执行扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // 如果是静态空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在minCapacity和默认大小10取最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 当前数组大小小于期望大小，数组需要扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // 扩容加上原来的一半大小，即原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 加上一半还是不够大的话就直接扩至期望大小 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 准备扩容大小超过的INT_MAX - 8 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 为负时说明超出了INT的范围，抛出OutOfMemoryError异常 // 否则MAX_ARRAY_SIZE刚好则为MAX_ARRAY_SIZE，还不够就INT_MAX newCapacity = hugeCapacity(minCapacity); // 将原数组拷贝到新的数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 5、删除元素12345678910111213141516171819202122232425public E remove(int index) &#123; // 数组边界检查，只对上限做了检查 rangeCheck(index); // 修改计数+1 modCount++; E oldValue = elementData(index); // 把删除的元素以后的元素向前移动 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;// Checks if the given index is in range. If not, throws an appropriate runtime exception.private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; ​ 这里值得注意的是rangeCheck和rangeCheckForAdd 的区别，函数的意义决定了函数的职责边界，从而对应内部的实现，如rangeCheck 是get、remove、set方法操作已存在元素的，所以只检查上边界，下边界检查的职责交给数组的访问，而rangeCheckForAdd 是add、addAll操作未存在元素的，所以检查上下边界。 6、迭代器的remove和ArrayList的remove123456789101112131415161718192021222324252627282930public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; // 同步期望计数 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125;// 修改计数和期望计数不相同，抛出异常final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125;private void fastRemove(int index) &#123; // 修改计数+1，后续没有进行同步期望计数，在遍历过程中会抛出ConcurrentModificationException modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 遍历删除元素时两种方法比较 通过迭代器Iterator#remove方法不会报错，而forEach调用至fastRemove由于没有同步期望计数，会抛出ConcurrentModificationException 所以这两个remove方法有一定的偏向性，即ArrayList的remove应该用于删除单个元素的场景 7、序列化机制12345678910111213141516171819202122232425262728293031323334353637383940414243private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; int expectedModCount = modCount; // 序列化non-static和non-transient的数据 s.defaultWriteObject(); // Q5:为什么这里还要write一次size呢？ // 这是为了版本兼容，老版本根据size这个成员变量去申请对应空间 // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // 序列化数组元素 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 8、总结Q1：添加、查找、遍历操作最为普遍，相应操作的原理是什么，时间复杂度是多少？ ​ 添加/删除操作，需要考虑具体的位置，在数组开头，需要移动元素，时间复杂度是O(n)，在数组尾部，时间复杂度是O(1)，遍历查找无序数组中的一个元素时间复杂度为O(n) Q2：如何进行动态扩展的？ ​ 当数组空间不足时进行动态扩展，扩展到原数组的1.5倍大小，仍不够的话扩展到期望大小（这种情况是初始化大小为10时或者addAll时发生），最多扩展至INT_MAX Q3：序列化机制是怎样的？ ​ 保存元素的element数组使用transient修饰，是避免序列化没有存储数据的空间提升性能，使用定制化的writeObject序列化和readObject反序列化","categories":[],"tags":[{"name":"Java源码","slug":"Java源码","permalink":"https://github.com/linlinnn/tags/Java%E6%BA%90%E7%A0%81/"}]},{"title":"Dubbo扩展点加载机制","slug":"dubbo扩展点","date":"2020-01-11T16:23:25.855Z","updated":"2020-01-19T13:42:15.643Z","comments":true,"path":"2020/01/12/dubbo扩展点/","link":"","permalink":"https://github.com/linlinnn/2020/01/12/dubbo%E6%89%A9%E5%B1%95%E7%82%B9/","excerpt":"","text":"Dubbo扩展点加载机制1、Java SPI使用了策略模式，一个接口多种实现。只声明接口，具体的实现由程序之外的配置控制，用于具体实现的装配。 具体步骤如下： （1）定义一个接口以及对应的方法 （2）编写接口的实现类 （3）在META-INF/services/ 目录下，创建一个接口全限定名命名的文件 （4）文件内容为具体实现类的全限定名，如果有多个，则用分行符分隔 （5）在代码中通过java.util.ServiceLoader 来加载具体的实现类 2、扩展点加载机制的改进 初始化 JDK SPI: 一次性实例化扩展点所有实现，初始化耗时，没有也加载浪费资源 Dubbo SPI: 加载配置文件中的类，并分为不同的种类缓存在内存中，不会立即全部初始化 扩展点加载失败 JDK SPI: 获取不到扩展的名称，不能打印正常的异常信息 Dubbo SPI: 抛出真实异常并打印日志，部分扩展点加载失败不会影响其他扩展点和整个框架的使用 实现了IOC和AOP机制 3、扩展点的配置规范 规范名 规范说明 SPI配置文件路径 META-INF/services/、META-INF/dubbo/、META-INF/dubbo/internal/ 全路径类名 文件内容格式 key=value方式，多个用换行符分隔 4、扩展点的分类与缓存Dubbo SPI Class缓存：Dubbo SPI获取扩展类时，先从缓存中读取。如果缓存中不存在，则加载配置文件，根据配置把Class缓存到内存中，不会直接初始化 实例缓存：基于性能考虑，Dubbo框架不仅会缓存Class，也会缓存Class实例化对象。先从缓存中读取，如果缓存中不存在，则重新加载并缓存起来，按需实例化并缓存 扩展类种类 普通扩展类 包装扩展类：Wrapper类没有具体的实现，只是做了通用逻辑的抽象，在构造方法中传入一个具体的扩展接口的实现 自适应扩展类：一个扩展接口有多种实现类，具体实现哪个实现类可以不写死在配置或代码中，在运行时，通过传入URL中的某些参数动态来确定。自适应特性@Adaptive 其他缓存 自适应和自动激活的区别？ isAssignableFrom 和 instanceof 的区别？ 123父类.class.isAssignableFrom(子类.class)子类实例 instanceof 父类类型","categories":[],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://github.com/linlinnn/tags/Dubbo/"}]}]}