<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>linjunhua&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/linlinnn/"/>
  <updated>2020-02-26T02:34:10.337Z</updated>
  <id>https://github.com/linlinnn/</id>
  
  <author>
    <name>linlinnn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://github.com/linlinnn/2020/02/26/test/"/>
    <id>https://github.com/linlinnn/2020/02/26/test/</id>
    <published>2020-02-26T02:34:10.000Z</published>
    <updated>2020-02-26T02:34:10.337Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java源码之ArrayList</title>
    <link href="https://github.com/linlinnn/2020/02/25/Java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/"/>
    <id>https://github.com/linlinnn/2020/02/25/Java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/</id>
    <published>2020-02-25T01:14:10.654Z</published>
    <updated>2020-02-26T02:14:01.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java源码之ArrayList"><a href="#Java源码之ArrayList" class="headerlink" title="Java源码之ArrayList"></a>Java源码之ArrayList</h1><h2 id="1、带着问题看源码"><a href="#1、带着问题看源码" class="headerlink" title="1、带着问题看源码"></a>1、带着问题看源码</h2><p>Q1：添加、查找、遍历操作最为普遍，相应操作的原理是什么，时间复杂度是多少？</p><p>Q2：如何进行动态扩展的？</p><p>Q3：序列化机制是怎样的？</p><h2 id="2、数据存储结构"><a href="#2、数据存储结构" class="headerlink" title="2、数据存储结构"></a>2、数据存储结构</h2><p>ArrayList在日常工作中非常常用，底层结构就是一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>1、<code>DEFAULT_CAPACITY</code>，初始大小为10</p><p>2、<code>EMPTY_ELEMENTDATA</code> 和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 的区别在于添加第一个元素时的扩容策略</p><p>3、<code>elementData</code>使用<code>transient</code>修饰，比如一个100万大小的数组，只存储了100个数据，那么只序列化这100个就好了，避免浪费不必要的资源，使用<code>writeObject</code>和<code>readObject</code>进行序列化</p><h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h2><p>有三种初始化方法：指定大小初始化，无参初始化，指定数据集合初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指定大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 返回静态的空数组EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始大小为负数，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回静态的空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在添加第一个元素后大小才为10</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">      <span class="comment">// 如果集合元素类型不是Object，转换成Object类型，Q4：为什么？</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回静态的空数组EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q4的测试代码如下，转换是为了防止数组元素赋值时发生类型错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello,ArrayList"</span>);</span><br><span class="line"></span><br><span class="line">Object[] arr = list.toArray();</span><br><span class="line">System.out.println(arr.getClass().getSimpleName()); <span class="comment">// String[]</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Object();<span class="comment">// java.lang.ArrayStoreException</span></span><br></pre></td></tr></table></figure><h2 id="4、添加元素"><a href="#4、添加元素" class="headerlink" title="4、添加元素"></a>4、添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保数组容量大小，不够时执行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是静态空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在minCapacity和默认大小10取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前数组大小小于期望大小，数组需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="comment">// 扩容加上原来的一半大小，即原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 加上一半还是不够大的话就直接扩至期望大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">// 准备扩容大小超过的INT_MAX - 8</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 为负时说明超出了INT的范围，抛出OutOfMemoryError异常</span></span><br><span class="line">        <span class="comment">// 否则MAX_ARRAY_SIZE刚好则为MAX_ARRAY_SIZE，还不够就INT_MAX</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将原数组拷贝到新的数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、删除元素"><a href="#5、删除元素" class="headerlink" title="5、删除元素"></a>5、删除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组边界检查，只对上限做了检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"><span class="comment">// 修改计数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"><span class="comment">// 把删除的元素以后的元素向前移动</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Checks if the given index is in range. If not, throws an appropriate runtime exception.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里值得注意的是<code>rangeCheck</code>和<code>rangeCheckForAdd</code> 的区别，<strong>函数的意义决定了函数的职责边界，从而对应内部的实现</strong>，如<code>rangeCheck</code> 是get、remove、set方法操作已存在元素的，所以只检查上边界，下边界检查的职责交给数组的访问，而<code>rangeCheckForAdd</code> 是add、addAll操作未存在元素的，所以检查上下边界。</p><h2 id="6、迭代器的remove和ArrayList的remove"><a href="#6、迭代器的remove和ArrayList的remove" class="headerlink" title="6、迭代器的remove和ArrayList的remove"></a>6、迭代器的remove和ArrayList的remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 同步期望计数</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改计数和期望计数不相同，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修改计数+1，后续没有进行同步期望计数，在遍历过程中会抛出ConcurrentModificationException</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历删除元素时两种方法比较</p><p>通过迭代器Iterator#remove方法不会报错，而forEach调用至fastRemove由于没有同步期望计数，会抛出<code>ConcurrentModificationException</code> 所以这两个remove方法有一定的偏向性，即ArrayList的remove应该用于删除单个元素的场景</p><h2 id="7、序列化机制"><a href="#7、序列化机制" class="headerlink" title="7、序列化机制"></a>7、序列化机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 序列化non-static和non-transient的数据</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"><span class="comment">// Q5:为什么这里还要write一次size呢？</span></span><br><span class="line">  <span class="comment">// 这是为了版本兼容，老版本根据size这个成员变量去申请对应空间</span></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">capacity</span>)</span>;</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>Q1：添加、查找、遍历操作最为普遍，相应操作的原理是什么，时间复杂度是多少？</p><p>​    添加/删除操作，需要考虑具体的位置，在数组开头，需要移动元素，时间复杂度是O(n)，在数组尾部，时间复杂度是O(1)，遍历查找无序数组中的一个元素时间复杂度为O(n)</p><p>Q2：如何进行动态扩展的？</p><p>​    当数组空间不足时进行动态扩展，扩展到原数组的1.5倍大小，仍不够的话扩展到期望大小（这种情况是初始化大小为10时或者addAll时发生），最多扩展至INT_MAX</p><p>Q3：序列化机制是怎样的？</p><p>​    保存元素的element数组使用transient修饰，是避免序列化没有存储数据的空间提升性能，使用定制化的writeObject序列化和readObject反序列化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java源码之ArrayList&quot;&gt;&lt;a href=&quot;#Java源码之ArrayList&quot; class=&quot;headerlink&quot; title=&quot;Java源码之ArrayList&quot;&gt;&lt;/a&gt;Java源码之ArrayList&lt;/h1&gt;&lt;h2 id=&quot;1、带着问题看源码
      
    
    </summary>
    
    
    
      <category term="Java源码" scheme="https://github.com/linlinnn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展点加载机制</title>
    <link href="https://github.com/linlinnn/2020/01/12/dubbo%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <id>https://github.com/linlinnn/2020/01/12/dubbo%E6%89%A9%E5%B1%95%E7%82%B9/</id>
    <published>2020-01-11T16:23:25.855Z</published>
    <updated>2020-01-19T13:42:15.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo扩展点加载机制"><a href="#Dubbo扩展点加载机制" class="headerlink" title="Dubbo扩展点加载机制"></a>Dubbo扩展点加载机制</h2><h3 id="1、Java-SPI"><a href="#1、Java-SPI" class="headerlink" title="1、Java SPI"></a>1、Java SPI</h3><p>使用了策略模式，一个接口多种实现。只声明接口，具体的实现由程序之外的配置控制，用于具体实现的装配。</p><p>具体步骤如下：</p><p>（1）定义一个接口以及对应的方法</p><p>（2）编写接口的实现类</p><p>（3）在<code>META-INF/services/</code> 目录下，创建一个接口全限定名命名的文件</p><p>（4）文件内容为具体实现类的全限定名，如果有多个，则用分行符分隔</p><p>（5）在代码中通过<code>java.util.ServiceLoader</code> 来加载具体的实现类</p><h3 id="2、扩展点加载机制的改进"><a href="#2、扩展点加载机制的改进" class="headerlink" title="2、扩展点加载机制的改进"></a>2、扩展点加载机制的改进</h3><ol><li>初始化<ul><li>JDK SPI: 一次性实例化扩展点所有实现，初始化耗时，没有也加载浪费资源</li><li>Dubbo SPI: 加载配置文件中的类，并分为不同的种类缓存在内存中，不会立即全部初始化</li></ul></li><li>扩展点加载失败<ul><li>JDK SPI: 获取不到扩展的名称，不能打印正常的异常信息</li><li>Dubbo SPI: 抛出真实异常并打印日志，部分扩展点加载失败不会影响其他扩展点和整个框架的使用</li></ul></li><li>实现了IOC和AOP机制</li></ol><h3 id="3、扩展点的配置规范"><a href="#3、扩展点的配置规范" class="headerlink" title="3、扩展点的配置规范"></a>3、扩展点的配置规范</h3><table><thead><tr><th>规范名</th><th>规范说明</th></tr></thead><tbody><tr><td>SPI配置文件路径</td><td>META-INF/services/、META-INF/dubbo/、META-INF/dubbo/internal/</td></tr><tr><td></td><td>全路径类名</td></tr><tr><td>文件内容格式</td><td>key=value方式，多个用换行符分隔</td></tr></tbody></table><h3 id="4、扩展点的分类与缓存"><a href="#4、扩展点的分类与缓存" class="headerlink" title="4、扩展点的分类与缓存"></a>4、扩展点的分类与缓存</h3><p>Dubbo SPI</p><ul><li>Class缓存：Dubbo SPI获取扩展类时，先从缓存中读取。如果缓存中不存在，则加载配置文件，根据配置把Class缓存到内存中，不会直接初始化</li><li>实例缓存：基于性能考虑，Dubbo框架不仅会缓存Class，也会缓存Class实例化对象。先从缓存中读取，如果缓存中不存在，则重新加载并缓存起来，按需实例化并缓存</li></ul><p>扩展类种类</p><ul><li>普通扩展类</li><li>包装扩展类：Wrapper类没有具体的实现，只是做了通用逻辑的抽象，在构造方法中传入一个具体的扩展接口的实现</li><li>自适应扩展类：一个扩展接口有多种实现类，具体实现哪个实现类可以不写死在配置或代码中，在运行时，通过传入URL中的某些参数动态来确定。自适应特性<code>@Adaptive</code></li><li>其他缓存</li></ul><p>自适应和自动激活的区别？</p><p><code>isAssignableFrom</code> 和 <code>instanceof</code> 的区别？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类.class.isAssignableFrom(子类.class)</span><br><span class="line"></span><br><span class="line">子类实例 instanceof 父类类型</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo扩展点加载机制&quot;&gt;&lt;a href=&quot;#Dubbo扩展点加载机制&quot; class=&quot;headerlink&quot; title=&quot;Dubbo扩展点加载机制&quot;&gt;&lt;/a&gt;Dubbo扩展点加载机制&lt;/h2&gt;&lt;h3 id=&quot;1、Java-SPI&quot;&gt;&lt;a href=&quot;#1、J
      
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="https://github.com/linlinnn/tags/Dubbo/"/>
    
  </entry>
  
</feed>
