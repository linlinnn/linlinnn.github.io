<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>linjunhua&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/linlinnn/"/>
  <updated>2020-04-11T15:12:34.708Z</updated>
  <id>https://github.com/linlinnn/</id>
  
  <author>
    <name>linlinnn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala 数据类型</title>
    <link href="https://github.com/linlinnn/2020/04/11/Scala%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://github.com/linlinnn/2020/04/11/Scala%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-04-11T15:08:26.415Z</published>
    <updated>2020-04-11T15:12:34.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scala-数据类型"><a href="#Scala-数据类型" class="headerlink" title="Scala 数据类型"></a>Scala 数据类型</h1><h3 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h3><h4 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h4><ul><li>方法是隶属于类或者对象的，在运行时，它是加载到JVM的方法区中</li><li>可以将函数对象赋值给一个变量，在运行时，它是加载到JVM的堆内存中</li><li><strong>函数是一个对象，继承自FunctionN</strong>，函数对象有<code>apply</code>，<code>curried</code>，<code>toString</code>，<code>tupled</code>这些方法，而方法则没有</li></ul><blockquote><p>最多是Function22 即最多只能有22个参数</p></blockquote><h4 id="方法转换为函数"><a href="#方法转换为函数" class="headerlink" title="方法转换为函数"></a>方法转换为函数</h4><ul><li>有时候需要将方法转换为函数，作为变量传递，就需要将方法转换为函数</li><li>使用<code>_</code>即可将方法转换为函数</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=x+y</span><br><span class="line">add: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = add _</span><br><span class="line">a: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &lt;function2&gt;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h4><ul><li>定长数组指的是数组的<strong>长度</strong>是<strong>不允许改变</strong>的</li><li>数组的<strong>元素</strong>是<strong>可以改变</strong>的</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过指定长度定义数组</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="type">Array</span>[元素类型](数组长度)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用元素直接初始化数组</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Array</span>(元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure><blockquote><p>在scala中，数组的泛型使用[]来指定<br>使用()来获取元素</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a=<span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br><span class="line">a: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; a(<span class="number">0</span>)</span><br><span class="line">res19: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; a(<span class="number">0</span>)=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">scala&gt; a</span><br><span class="line">res21: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="type">Array</span>(<span class="string">"hadoop"</span>,<span class="string">"spark"</span>,<span class="string">"hive"</span>)</span><br><span class="line">b: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(hadoop, spark, hive)</span><br><span class="line"></span><br><span class="line">scala&gt; b(<span class="number">0</span>)</span><br><span class="line">res24: <span class="type">String</span> = hadoop</span><br><span class="line"></span><br><span class="line">scala&gt; b.length</span><br><span class="line">res25: <span class="type">Int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><ul><li>变长数组指的是数组的长度是可变的，可以往数组中添加、删除元素</li><li>创建变长数组，需要提前导入ArrayBuffer类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的ArrayBuffer变长数组</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> a = <span class="type">ArrayBuffer</span>[元素类型]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建带有初始元素的ArrayBuffer</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> a = <span class="type">ArrayBuffer</span>(元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>...)</span><br></pre></td></tr></table></figure><h5 id="变长数组的增删改操作"><a href="#变长数组的增删改操作" class="headerlink" title="变长数组的增删改操作"></a>变长数组的增删改操作</h5><ul><li>使用<code>+=</code>添加元素</li><li>使用<code>-=</code>删除元素</li><li>使用<code>++=</code>追加一个数组到变长数组</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变长数组</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">ArrayBuffer</span>(<span class="string">"hadoop"</span>, <span class="string">"spark"</span>, <span class="string">"flink"</span>)</span><br><span class="line">a: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">String</span>] = <span class="type">ArrayBuffer</span>(hadoop, spark, flink)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">scala&gt; a += <span class="string">"flume"</span></span><br><span class="line">res10: a<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ArrayBuffer</span>(hadoop, spark, flink, flume)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个元素</span></span><br><span class="line">scala&gt; a -= <span class="string">"hadoop"</span></span><br><span class="line">res11: a<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ArrayBuffer</span>(spark, flink, flume)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一个数组</span></span><br><span class="line">scala&gt; a ++= <span class="type">Array</span>(<span class="string">"hive"</span>, <span class="string">"sqoop"</span>)</span><br><span class="line">res12: a<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ArrayBuffer</span>(spark, flink, flume, hive, sqoop)</span><br></pre></td></tr></table></figure><h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><p>可以使用以下两种方式来遍历数组：</p><ul><li>使用 <strong>for表达式</strong> 直接遍历数组中的元素</li><li>使用 <strong>索引</strong> 遍历数组中的元素</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- a) println(i)</span><br><span class="line">hadoop</span><br><span class="line">hive</span><br><span class="line">flume</span><br><span class="line">spark</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to a.length <span class="number">-1</span> ) println(a(i))</span><br><span class="line">hadoop</span><br><span class="line">hive</span><br><span class="line">flume</span><br><span class="line">spark</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until a.length) println(a(i))</span><br><span class="line">hadoop</span><br><span class="line">hive</span><br><span class="line">flume</span><br><span class="line">spark</span><br></pre></td></tr></table></figure><blockquote><p>0 to n =&gt; [0, n]</p><p>0 until n =&gt; [0. n)</p></blockquote><h4 id="数组常用操作"><a href="#数组常用操作" class="headerlink" title="数组常用操作"></a>数组常用操作</h4><p>scala中的数组封装了丰富的计算操作，将来在对数据处理的时候，不需要我们自己再重新实现。</p><ul><li>求和——sum方法</li><li>求最大值——max方法 </li><li>求最小值——min方法 </li><li>排序——sorted方法</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">scala&gt; array.sum</span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大值</span></span><br><span class="line">scala&gt; array.max</span><br><span class="line">res11: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求最小值</span></span><br><span class="line">scala&gt; array.min</span><br><span class="line">res12: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line">scala&gt; array.sorted</span><br><span class="line">res13: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序 reverse 反转</span></span><br><span class="line">scala&gt; array.sorted.reverse</span><br><span class="line">res14: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组可以用来包含一组不同类型的值。例如：姓名，年龄，性别，出生年月</p><p>元组的元素是不可变的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用括号来定义元组</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 元组变量名称 = (元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头来定义元素（元组只有两个元素）</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 元组 = 元素<span class="number">1</span>-&gt;元素<span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = (<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">20</span>, <span class="string">"北京市"</span>) </span><br><span class="line">a: (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>, <span class="type">String</span>) = (<span class="number">1</span>,张三,<span class="number">20</span>,北京市)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="number">1</span>-&gt;<span class="number">2</span> </span><br><span class="line">b: (<span class="type">Int</span>, <span class="type">Int</span>) = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元组_1、_2、_3....</span></span><br><span class="line"><span class="comment">// 获取元组中的第一个元素</span></span><br><span class="line">scala&gt; a._1</span><br><span class="line">res18: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能修改元组中的值</span></span><br><span class="line">scala&gt; a._4=<span class="string">"上海"</span></span><br><span class="line">&lt;console&gt;:<span class="number">12</span>: error: reassignment to <span class="keyword">val</span></span><br><span class="line">       a._4=<span class="string">"上海"</span></span><br><span class="line">           ^</span><br></pre></td></tr></table></figure><h3 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h3><ul><li>Map可以称之为映射。它是由键值对组成的集合。scala当中的Map集合与java当中的Map类似，也是key，value对形式的。</li><li>在scala中，Map也分为不可变Map和可变Map。</li></ul><h4 id="不可变Map"><a href="#不可变Map" class="headerlink" title="不可变Map"></a>不可变Map</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> map = <span class="type">Map</span>(键-&gt;值, 键-&gt;值, 键-&gt;值...)    <span class="comment">// 推荐，可读性更好 </span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> map = <span class="type">Map</span>((键, 值), (键, 值), (键, 值), (键, 值)...)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> map1 = <span class="type">Map</span>(<span class="string">"zhangsan"</span>-&gt;<span class="number">30</span>, <span class="string">"lisi"</span>-&gt;<span class="number">40</span>) </span><br><span class="line">map: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(zhangsan -&gt; <span class="number">30</span>, lisi -&gt; <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> map2 = <span class="type">Map</span>((<span class="string">"zhangsan"</span>, <span class="number">30</span>), (<span class="string">"lisi"</span>, <span class="number">30</span>)) </span><br><span class="line">map: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(zhangsan -&gt; <span class="number">30</span>, lisi -&gt; <span class="number">30</span>)</span><br><span class="line"><span class="comment">// 根据key获取value </span></span><br><span class="line">scala&gt; map1(<span class="string">"zhangsan"</span>) </span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="可变Map"><a href="#可变Map" class="headerlink" title="可变Map"></a>可变Map</h4><p>可变Map需要手动导入<code>import scala.collection.mutable.Map</code>, 定义语法与不可变Map一致</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">Map</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义可变的map</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> map3 = <span class="type">Map</span>(<span class="string">"zhangsan"</span>-&gt;<span class="number">30</span>, <span class="string">"lisi"</span>-&gt;<span class="number">40</span>)</span><br><span class="line">map3: scala.collection.mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(lisi -&gt; <span class="number">40</span>, zhangsan -&gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取zhangsan这个key对应的value</span></span><br><span class="line">scala&gt; map3(<span class="string">"zhangsan"</span>)</span><br><span class="line">res26: <span class="type">Int</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给zhangsan这个key重新赋值value</span></span><br><span class="line">scala&gt; map3(<span class="string">"zhangsan"</span>)=<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示map3</span></span><br><span class="line">scala&gt; map3</span><br><span class="line">res28: scala.collection.mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(lisi -&gt; <span class="number">40</span>, zhangsan -&gt; <span class="number">50</span>)</span><br></pre></td></tr></table></figure><h4 id="Map基本操作"><a href="#Map基本操作" class="headerlink" title="Map基本操作"></a>Map基本操作</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取zhangsan的年龄 </span></span><br><span class="line">scala&gt; map(<span class="string">"zhangsan"</span>)</span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取wangwu的年龄，如果wangwu不存在，则返回-1 比较友好，避免遇到不存在的key而报错</span></span><br><span class="line">scala&gt; map.getOrElse(<span class="string">"wangwu"</span>, <span class="number">-1</span>) </span><br><span class="line">res11: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改key对应的value</span></span><br><span class="line">scala&gt; map(<span class="string">"lisi"</span>)=<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加key-value键值对</span></span><br><span class="line">scala&gt; map+=(<span class="string">"wangwu"</span> -&gt;<span class="number">35</span>)</span><br><span class="line">res12: map<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Map</span>(lisi -&gt; <span class="number">50</span>, zhangsan -&gt; <span class="number">30</span>, wangwu -&gt; <span class="number">35</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除key-value键值对</span></span><br><span class="line">scala&gt; map -=<span class="string">"wangwu"</span></span><br><span class="line">res13: map<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Map</span>(lisi -&gt; <span class="number">50</span>, zhangsan -&gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的key</span></span><br><span class="line">scala&gt; map.keys</span><br><span class="line">res36: <span class="type">Iterable</span>[<span class="type">String</span>] = <span class="type">Set</span>(lisi, zhangsan)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的key</span></span><br><span class="line">scala&gt; map.keySet</span><br><span class="line">res37: scala.collection.<span class="type">Set</span>[<span class="type">String</span>] = <span class="type">Set</span>(lisi, zhangsan)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的value</span></span><br><span class="line">scala&gt; map.values</span><br><span class="line">res38: <span class="type">Iterable</span>[<span class="type">Int</span>] = <span class="type">HashMap</span>(<span class="number">50</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h5 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种遍历</span></span><br><span class="line">scala&gt; <span class="keyword">for</span>(k &lt;- map.keys) println(k + <span class="string">" -&gt; "</span> + map(k))</span><br><span class="line">lisi -&gt; <span class="number">50</span></span><br><span class="line">zhangsan -&gt; <span class="number">30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历</span></span><br><span class="line">scala&gt; <span class="keyword">for</span>((k,v) &lt;- map) println(k + <span class="string">" -&gt; "</span> + v)</span><br><span class="line">lisi -&gt; <span class="number">50</span></span><br><span class="line">zhangsan -&gt; <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul><li>Set是代表没有重复元素的集合。</li><li>Set具备以下性质：<ul><li>1、元素不重复 </li><li>2、不保证插入顺序</li></ul></li><li>scala中的集也分为两种，一种是不可变集合，另一种是可变集合。</li></ul><h4 id="不可变Set集合"><a href="#不可变Set集合" class="headerlink" title="不可变Set集合"></a>不可变Set集合</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空的不可变集</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Set</span>[类型]()</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定元素来创建一个不可变集</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Set</span>[类型](元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建set集合 </span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) </span><br><span class="line">a: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合的大小 </span></span><br><span class="line">scala&gt; a.size </span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line">scala&gt; <span class="keyword">for</span>(i &lt;- a) println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素生成新的集合</span></span><br><span class="line">scala&gt; a + <span class="number">6</span></span><br><span class="line">res1: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个元素 </span></span><br><span class="line">scala&gt; a - <span class="number">1</span> </span><br><span class="line">res2: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除set集合中存在的元素 </span></span><br><span class="line">scala&gt; a -- <span class="type">Set</span>(<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">res3: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接两个集合 </span></span><br><span class="line">scala&gt; a ++ <span class="type">Set</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>) </span><br><span class="line">res4: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求2个Set集合的交集</span></span><br><span class="line">scala&gt; a &amp; <span class="type">Set</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">res5: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里对不可变的set集合进行添加删除等操作，对于该集合来说是没有发生任何变化，这里是生成了新的集合，新的集合相比于原来的集合来说发生了变化</p></blockquote><h4 id="可变Set集合"><a href="#可变Set集合" class="headerlink" title="可变Set集合"></a>可变Set集合</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">Set</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义可变的set集合</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> set=<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">set: scala.collection.mutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加单个元素</span></span><br><span class="line">scala&gt; set +=<span class="number">6</span></span><br><span class="line">res10: set<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Set</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加多个元素</span></span><br><span class="line">scala&gt; set += (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">res11: set<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Set</span>(<span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个set集合中的元素</span></span><br><span class="line">scala&gt; set ++=<span class="type">Set</span>(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">res12: set<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Set</span>(<span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个元素</span></span><br><span class="line">scala&gt; set -=<span class="number">11</span></span><br><span class="line">res13: set<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Set</span>(<span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除多个元素</span></span><br><span class="line">scala&gt; set -= (<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">res15: set<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Set</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个set子集</span></span><br><span class="line">scala&gt; set --= <span class="type">Set</span>(<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">res19: set<span class="class">.<span class="keyword">type</span> </span>= <span class="type">Set</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; set.remove(<span class="number">1</span>)</span><br><span class="line">res17: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; set</span><br><span class="line">res18: scala.collection.mutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h3><ul><li>List是scala中最重要的、也是最常用的数据结构</li><li>List具备以下性质：<ul><li>1、可以保存重复的值 </li><li>2、有先后顺序</li></ul></li><li>在scala中，也有两种列表，一种是不可变列表、另一种是可变列表</li></ul><h4 id="不可变列表"><a href="#不可变列表" class="headerlink" title="不可变列表"></a>不可变列表</h4><ul><li>不可变列表就是列表的元素、长度都是不可变的</li><li>语法<ul><li>使用 List(元素1, 元素2, 元素3, …) 来创建一个不可变列表，语法格式</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">List</span>(元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Nil 创建一个不可变的空列表</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 :: 方法创建一个不可变列表</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = 元素<span class="number">1</span> :: 元素<span class="number">2</span> :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个不可变列表，存放以下几个元素（1,2,3,4）</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">list1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Nil创建一个不可变的空列表</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list2 = <span class="type">Nil</span></span><br><span class="line">list2: scala.collection.immutable.<span class="type">Nil</span><span class="class">.<span class="keyword">type</span> </span>= <span class="type">List</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 :: 方法创建列表，包含1、2、3三个元素</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list3 = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="type">Nil</span></span><br><span class="line">list3: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="可变列表"><a href="#可变列表" class="headerlink" title="可变列表"></a>可变列表</h4><ul><li>可变列表就是列表的元素、长度都是可变的。</li><li>要使用可变列表，先要导入 <code>import scala.collection.mutable.ListBuffer</code></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个空的可变列表</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a=<span class="type">ListBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">a: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Int</span>] = <span class="type">ListBuffer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个有初始元素的可变列表</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> b=<span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Int</span>] = <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个可变的列表</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list=<span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">list: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Int</span>] = <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第一个元素</span></span><br><span class="line">scala&gt; list(<span class="number">0</span>)</span><br><span class="line">res4: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//获取第一个元素</span></span><br><span class="line">scala&gt; list.head</span><br><span class="line">res5: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取除了第一个元素外其他元素组成的列表</span></span><br><span class="line">scala&gt; list.tail</span><br><span class="line">res6: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Int</span>] = <span class="type">ListBuffer</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加单个元素</span></span><br><span class="line">scala&gt; list +=<span class="number">5</span></span><br><span class="line">res7: list<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个不可变的列表</span></span><br><span class="line">scala&gt; list ++=<span class="type">List</span>(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">res8: list<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个可变的列表</span></span><br><span class="line">scala&gt; list ++=<span class="type">ListBuffer</span>(<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">res9: list<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除单个元素</span></span><br><span class="line">scala&gt; list -=<span class="number">9</span></span><br><span class="line">res10: list<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个不可变的列表存在的元素</span></span><br><span class="line">scala&gt; list --= <span class="type">List</span>(<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">res11: list<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个可变的列表存在的元素</span></span><br><span class="line">scala&gt; list --= <span class="type">ListBuffer</span>(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">res12: list<span class="class">.<span class="keyword">type</span> </span>= <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变的列表转为不可变列表</span></span><br><span class="line">scala&gt; list.toList</span><br><span class="line">res13: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变的列表转为不可变数组</span></span><br><span class="line">scala&gt; list.toArray</span><br><span class="line">res14: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scala-数据类型&quot;&gt;&lt;a href=&quot;#Scala-数据类型&quot; class=&quot;headerlink&quot; title=&quot;Scala 数据类型&quot;&gt;&lt;/a&gt;Scala 数据类型&lt;/h1&gt;&lt;h3 id=&quot;方法和函数&quot;&gt;&lt;a href=&quot;#方法和函数&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="Scala" scheme="https://github.com/linlinnn/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala 面对对象编程</title>
    <link href="https://github.com/linlinnn/2020/04/11/Scala%20%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/linlinnn/2020/04/11/Scala%20%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-11T15:08:26.400Z</published>
    <updated>2020-04-11T15:14:19.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scala-面对对象编程"><a href="#Scala-面对对象编程" class="headerlink" title="Scala 面对对象编程"></a>Scala 面对对象编程</h1><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>scala是支持面向对象的，也有类和对象的概念</p><ul><li>定义一个Customer类，并添加成员变量/成员方法</li><li>添加一个main方法，并创建Customer类的对象，并给对象赋值，打印对象中的成员，调用成员方法</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line">  <span class="keyword">var</span> sex:<span class="type">String</span> = _</span><br><span class="line">  <span class="keyword">val</span> registerDate:<span class="type">Date</span> = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>(msg:<span class="type">String</span>) = &#123;</span><br><span class="line">    println(msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> customer = <span class="keyword">new</span> <span class="type">Customer</span></span><br><span class="line">    <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">    customer.name = <span class="string">"张三"</span></span><br><span class="line">    customer.sex = <span class="string">"男"</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">s"姓名: <span class="subst">$&#123;customer.name&#125;</span>, 性别：<span class="subst">$&#123;customer.sex&#125;</span>, 注册时间: <span class="subst">$&#123;customer.registerDate&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">//对象调用方法  </span></span><br><span class="line">    customer.sayHi(<span class="string">"你好!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>var name:String = _，  _表示使用默认值进行初始化</p><p>   例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false…</p></li><li><p>val变量不能使用_来进行初始化，因为val是不可变的，所以必须手动指定一个默认值</p></li><li><p>main方法必须要放在一个scala的object（单例对象）中才能执行</p></li></ol></blockquote><h4 id="类的构造器"><a href="#类的构造器" class="headerlink" title="类的构造器"></a>类的构造器</h4><h5 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h5><ul><li>主构造器是指在类名的后面跟上一系列参数，例如</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span>(<span class="params">var/val 参数名:类型 = 默认值, var/val 参数名:类型 = 默认值</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="辅助构造器"><a href="#辅助构造器" class="headerlink" title="辅助构造器"></a>辅助构造器</h5><ul><li>在类中使用this来定义，例如</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(参数名:类型, 参数名:类型) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name:<span class="type">String</span>, val age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> address:<span class="type">String</span>=<span class="string">"beijing"</span> </span><br><span class="line">  <span class="comment">// 定义一个参数的辅助构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一行必须调用主构造器、其他辅助构造器或者super父类的构造器</span></span><br><span class="line">    <span class="keyword">this</span>(name, <span class="number">20</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(age:<span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"某某某"</span>, age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>scala中是没有Java中的静态成员的。如果将来我们需要用到static变量、static方法，就要用到scala中的单例对象object</li><li>定义object<ul><li>定义单例对象和定义类很像，就是把class换成object</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在object中定义的成员变量，相当于Java中定义一个静态变量</span></span><br><span class="line">  <span class="comment">// 定义一个SimpleDateFormat日期时间格式化对象</span></span><br><span class="line">  <span class="keyword">val</span> simpleDateFormat = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">"yyyy-MM-dd HH:mm"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造代码</span></span><br><span class="line">  println(<span class="string">"构造代码"</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 相当于Java中定义一个静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">format</span></span>(date:<span class="type">Date</span>) = simpleDateFormat.format(date)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main是一个静态方法，所以必须要写在object中</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println &#123; <span class="type">DateUtils</span>.format(<span class="keyword">new</span> <span class="type">Date</span>()) &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(1). 使用object单例对象名定义一个单例对象，可以用object作为工具类或者存放常量<br>(2). 在单例对象中定义的变量，类似于Java中的static成员变量<br>(3). 在单例对象中定义的方法，类似于Java中的static方法<br>(4). object单例对象的构造代码可以直接写在花括号中<br>(5). 调用单例对象的方法，直接使用单例对象名.方法名，访问单例对象的成员变量也是使用单例对象名.变量名<br>(6). <strong>单例对象只能有一个无参的主构造器，不能添加其他参数</strong></p></blockquote><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><ul><li>在同一个scala文件，有一个class和object具有同样的名字，那么就称这个object是class的伴生对象，class是object的伴生类；</li><li>伴生类和伴生对象的最大特点是，<strong>可以相互访问</strong>；</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> id = <span class="number">1</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">"itcast"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printName</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="comment">//在ClassObject类中可以访问伴生对象ClassObject的私有属性</span></span><br><span class="line">    println(<span class="type">ClassObject</span>.<span class="type">CONSTANT</span> + name )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClassObject</span></span>&#123;</span><br><span class="line">  <span class="comment">//伴生对象中的私有属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> <span class="type">CONSTANT</span> = <span class="string">"汪汪汪 : "</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">ClassObject</span></span><br><span class="line">    <span class="comment">//访问私有的字段name</span></span><br><span class="line">    p.name = <span class="string">"123"</span></span><br><span class="line">    p.printName()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(1). 伴生类和伴生对象的名字必须是一样的<br>(2). 伴生类和伴生对象需要在一个scala源文件中<br>(3). 伴生类和伴生对象可以互相访问private的属性</p></blockquote><h3 id="object的apply方法"><a href="#object的apply方法" class="headerlink" title="object的apply方法"></a>object的apply方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Array对象</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>这种写法非常简便，不需要再写一个new，然后敲一个空格，再写类名。如何直接使用类名来创建对象呢？</p><p><strong>实现伴生对象的apply方法</strong></p><p>伴生对象的apply方法用来快速地创建一个伴生类的对象</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var name:<span class="type">String</span>, var age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"Person(<span class="subst">$name</span>, <span class="subst">$age</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现apply方法</span></span><br><span class="line">  <span class="comment">// 返回的是伴生类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>): <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name, age)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply方法支持重载</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name:<span class="type">String</span>):<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(age:<span class="type">Int</span>):<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"某某某"</span>, age)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>():<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"某某某"</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="type">Person</span>(<span class="string">"张三"</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="type">Person</span>(<span class="string">"李四"</span>)</span><br><span class="line">    <span class="keyword">val</span> p3 = <span class="type">Person</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> p4 = <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line">    println(p1)</span><br><span class="line">    println(p2)</span><br><span class="line">    println(p3)</span><br><span class="line">    println(p4)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（1）当遇到类名(参数1, 参数2…)会自动调用apply方法，在apply方法中来创建对象<br>（2）定义apply时，<strong>如果参数列表是空，也不能省略括号()</strong>，否则引用的是伴生对象</p></blockquote><h3 id="object的main方法"><a href="#object的main方法" class="headerlink" title="object的main方法"></a>object的main方法</h3><ul><li>scala和Java一样，如果要运行一个程序，必须有一个main方法。</li><li>而在Java中main方法是静态的，而在scala中没有静态方法。</li><li><strong>在scala中，这个main方法必须放在一个object中</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    println(<span class="string">"hello, scala"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以继承自App Trait（特质），然后将需要编写在main方法中的代码，写在object的构造方法体内。其本质是调用了Trait这个特质中的main方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main2</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"hello, scala"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait特质"><a href="#trait特质" class="headerlink" title="trait特质"></a>trait特质</h3><p>​    大多数场景下，Scala中的特质（trait）相当于Java中的接口，正如Java类能够实现多个接口一样，Scala</p><p>类可以继承多个特质，由于特质能够像Java中的抽象类那样包含自己已实现的方法，所以特质的功能要比</p><p>Java接口强大得多。然而，和Java中的抽象类不同，Scala可以把多个特质混入到一个类中，与此同时，一个</p><p>特质也能控制它混入的类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BaseSoundPlayer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">play</span></span></span><br><span class="line"><span class="function">  <span class="title">def</span> <span class="title">close</span> </span></span><br><span class="line"><span class="function">  <span class="title">def</span> <span class="title">pause</span></span></span><br><span class="line"><span class="function">  <span class="title">def</span> <span class="title">stop</span></span></span><br><span class="line"><span class="function">  <span class="title">def</span> <span class="title">resume</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果方法不需要任何参数，在def后指定方法名即可，如上所示。如果一个方法需要参数，只需要把它</p><p>们罗列出来即可</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">speak</span></span>(whatToSay: <span class="type">String</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wagTail</span></span>(enabled: <span class="type">Boolean</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承特质"><a href="#继承特质" class="headerlink" title="继承特质"></a>继承特质</h4><p>当一个类需要继承特质时，要使用extends和with关键字。只继承一个特质时，使用extends</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mp3SoundPlayer</span> <span class="keyword">extends</span> <span class="title">BaseSoundPlayer</span></span></span><br></pre></td></tr></table></figure><p>继承一个类和多个特质时</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> <span class="keyword">with</span> <span class="title">trait1</span> <span class="keyword">with</span> <span class="title">trait2</span></span></span><br></pre></td></tr></table></figure><p>继承多个特质时</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">trait1</span> <span class="keyword">with</span> <span class="title">trait2</span> <span class="keyword">with</span> <span class="title">trait3</span></span></span><br></pre></td></tr></table></figure><blockquote><p>除非实现特质的类是一个抽象类，否则必须实现特质的所有抽象方法</p><p>特质也可以继承另一个特质</p></blockquote><h4 id="特质的字段"><a href="#特质的字段" class="headerlink" title="特质的字段"></a>特质的字段</h4><p>一个特质的字段可以声明为var或者val。在一个子类（或子特质）中覆写特质中的var字段时，不需要</p><p>override关键字，但当覆写一个特质中的val字段时，需要使用override关键字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PizzaTrait</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> numToppings: <span class="type">Int</span> <span class="comment">//抽象字段，子类需要定义（除非为抽象类）</span></span><br><span class="line">  <span class="keyword">var</span> size = <span class="number">14</span></span><br><span class="line">  <span class="keyword">val</span> maxNumToppings = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> <span class="keyword">extends</span> <span class="title">PizzaTrait</span></span>&#123;</span><br><span class="line">  numToppings = <span class="number">0</span> <span class="comment">// 'override' and 'var' not needed</span></span><br><span class="line">  size = <span class="number">16</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> maxNumToppings = <span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><ul><li>scala有一个十分强大的模式匹配机制，可以应用到很多场合。<ul><li>switch语句</li><li>类型查询</li><li>快速获取数据</li></ul></li><li>并且scala还提供了样例类，对模式匹配进行了优化，可以快速进行匹配。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseDemo01</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个数组</span></span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="string">"hadoop"</span>,<span class="string">"zookeeper"</span>,<span class="string">"spark"</span>,<span class="string">"storm"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机取数组中的一位，使用Random.nextInt</span></span><br><span class="line">  <span class="keyword">val</span> name = arr(<span class="type">Random</span>.nextInt(arr.length))</span><br><span class="line">  println(name)</span><br><span class="line"></span><br><span class="line">  name <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hadoop"</span>     =&gt; println(<span class="string">"大数据分布式存储和计算框架..."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"zookeeper"</span>  =&gt; println(<span class="string">"大数据分布式协调服务框架..."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"spark"</span>      =&gt; println(<span class="string">"大数据分布式内存计算框架..."</span>)</span><br><span class="line">    <span class="comment">//表示以上情况都不满足才会走最后一个</span></span><br><span class="line">    <span class="keyword">case</span> _            =&gt; println(<span class="string">"我不认识你"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseDemo02</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义一个数组</span></span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="string">"hello"</span>,<span class="number">1</span>,<span class="number">-2.0</span>,<span class="type">CaseDemo02</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机获取数组中的元素</span></span><br><span class="line">  <span class="keyword">val</span> value=arr(<span class="type">Random</span>.nextInt(arr.length))</span><br><span class="line">  println(value)</span><br><span class="line"></span><br><span class="line">  value <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x:<span class="type">Int</span>                =&gt; println(<span class="string">"Int=&gt;"</span>+x)</span><br><span class="line">    <span class="keyword">case</span> y:<span class="type">Double</span> <span class="keyword">if</span>(y&gt;=<span class="number">0</span>)    =&gt; println(<span class="string">"Double=&gt;"</span>+y)</span><br><span class="line">    <span class="keyword">case</span> z:<span class="type">String</span>             =&gt; println(<span class="string">"String=&gt;"</span>+z)</span><br><span class="line">    <span class="keyword">case</span> _                    =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"not match exception"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配数组"><a href="#匹配数组" class="headerlink" title="匹配数组"></a>匹配数组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseDemo03</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//匹配数组</span></span><br><span class="line">  <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">  arr <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">1</span>,x,y) =&gt; println(x+<span class="string">"---"</span>+y)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">1</span>,_*)  =&gt; println(<span class="string">"1..."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>)     =&gt; println(<span class="string">"only 0"</span>)</span><br><span class="line">    <span class="keyword">case</span> _            =&gt; println(<span class="string">"something else"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配集合"><a href="#匹配集合" class="headerlink" title="匹配集合"></a>匹配集合</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseDemo04</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> list=<span class="type">List</span>(<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line">  list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>::<span class="type">Nil</span>        =&gt; println(<span class="string">"only 0"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>::tail       =&gt; println(<span class="string">"0...."</span>)</span><br><span class="line">    <span class="keyword">case</span> x::y::z::<span class="type">Nil</span>  =&gt; println(<span class="string">s"x:<span class="subst">$x</span> y:<span class="subst">$y</span> z:<span class="subst">$z</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> _             =&gt; println(<span class="string">"something else"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配元组"><a href="#匹配元组" class="headerlink" title="匹配元组"></a>匹配元组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CaseDemo05</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> tuple = (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">  tuple <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">1</span>,x,y)    =&gt; println(<span class="string">s"1,<span class="subst">$x</span>,<span class="subst">$y</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">2</span>,x,y)    =&gt; println(<span class="string">s"<span class="subst">$x</span>,<span class="subst">$y</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> _          =&gt; println(<span class="string">"others..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例类"><a href="#案例类" class="headerlink" title="案例类"></a>案例类</h3><p>案例类（Case classes）和普通类差不多，非常适合用于不可变的数据</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">isbn: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">frankenstein</span> </span>= <span class="type">Book</span>(<span class="string">"978-0486282114"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意在实例化案例类<code>Book</code>时，并没有使用关键字<code>new</code>，这是因为案例类有一个默认的<code>apply</code>方法来负</p><p>责对象的创建。</p></blockquote><p>当创建包含参数的案例类时，这些参数是公开（public）的<code>val</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>(<span class="params">sender: <span class="type">String</span>, recipient: <span class="type">String</span>, body: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">message1</span> </span>= <span class="type">Message</span>(<span class="string">"guillaume@quebec.ca"</span>, <span class="string">"jorge@catalonia.es"</span>, <span class="string">"Ça va ?"</span>)</span><br><span class="line"></span><br><span class="line">println(message1.sender)  <span class="comment">// prints guillaume@quebec.ca</span></span><br><span class="line">message1.sender = <span class="string">"travis@washington.us"</span>  <span class="comment">// this line does not compile</span></span><br></pre></td></tr></table></figure><blockquote><p>不能给<code>message1.sender</code>重新赋值，因为它是一个<code>val</code>（不可变）。在案例类中使用<code>var</code>也是可以的，但</p><p>并不推荐这样。</p></blockquote><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>案例类在比较的时候是按值比较而非按引用比较</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>(<span class="params">sender: <span class="type">String</span>, recipient: <span class="type">String</span>, body: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">message2</span> </span>= <span class="type">Message</span>(<span class="string">"jorge@catalonia.es"</span>, <span class="string">"guillaume@quebec.ca"</span>, <span class="string">"Com va?"</span>)</span><br><span class="line"><span class="keyword">val</span> message3 = <span class="type">Message</span>(<span class="string">"jorge@catalonia.es"</span>, <span class="string">"guillaume@quebec.ca"</span>, <span class="string">"Com va?"</span>)</span><br><span class="line"><span class="keyword">val</span> messagesAreTheSame = message2 == message3  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>可以通过<code>copy</code>方法创建一个案例类实例的浅拷贝，同时可以指定构造参数来做一些改变</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>(<span class="params">sender: <span class="type">String</span>, recipient: <span class="type">String</span>, body: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">message4</span> </span>= <span class="type">Message</span>(<span class="string">"julien@bretagne.fr"</span>, <span class="string">"travis@washington.us"</span>, <span class="string">"Me zo o komz gant ma amezeg"</span>)</span><br><span class="line"><span class="keyword">val</span> message5 = message4.copy(sender = message4.recipient, recipient = <span class="string">"claire@bourgogne.fr"</span>)</span><br><span class="line">message5.sender  <span class="comment">// travis@washington.us</span></span><br><span class="line">message5.recipient <span class="comment">// claire@bourgogne.fr</span></span><br><span class="line">message5.body  <span class="comment">// "Me zo o komz gant ma amezeg"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scala-面对对象编程&quot;&gt;&lt;a href=&quot;#Scala-面对对象编程&quot; class=&quot;headerlink&quot; title=&quot;Scala 面对对象编程&quot;&gt;&lt;/a&gt;Scala 面对对象编程&lt;/h1&gt;&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="Scala" scheme="https://github.com/linlinnn/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala 函数式编程</title>
    <link href="https://github.com/linlinnn/2020/04/11/Scala%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/linlinnn/2020/04/11/Scala%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-11T15:08:26.380Z</published>
    <updated>2020-04-11T15:15:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scala-函数式编程"><a href="#Scala-函数式编程" class="headerlink" title="Scala 函数式编程"></a>Scala 函数式编程</h1><h3 id="遍历-foreach"><a href="#遍历-foreach" class="headerlink" title="遍历 - foreach"></a>遍历 - foreach</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach(f: (<span class="type">A</span>) ⇒ <span class="type">Unit</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>foreach</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>参数</td><td>f: (A) ⇒ Unit</td><td>接收一个函数对象<br>函数的输入参数为集合的元素<br>返回值为空</td></tr><tr><td>返回值</td><td>Unit</td><td>空</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名函数的输入参数类型可以省略，由编译器自动推断</span></span><br><span class="line">scala&gt; list.foreach(x=&gt;println(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//当函数参数，只在函数体中出现一次，而且函数体没有嵌套调用时，可以使用下划线来简化函数定义</span></span><br><span class="line">scala&gt; list.foreach(println(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简写，直接给定println</span></span><br><span class="line">scala&gt; list.foreach(println)</span><br></pre></td></tr></table></figure><h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 - map"></a>映射 - map</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: (<span class="type">A</span>) ⇒ <span class="type">B</span>): <span class="type">TraversableOnce</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>map方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>泛型</td><td>[B]</td><td>指定map方法最终返回的集合泛型</td></tr><tr><td>参数</td><td>f: (A) ⇒ B</td><td>传入一个函数对象<br>该函数接收一个类型A（要转换的列表元素）<br>返回值为类型B</td></tr><tr><td>返回值</td><td>TraversableOnce[B]</td><td>B类型的集合</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个list集合，实现把内部每一个元素做乘以10，生成一个新的list集合</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list=<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略匿名函数参数类型</span></span><br><span class="line">scala&gt; list.map(x=&gt;x*<span class="number">10</span>)</span><br><span class="line">res22: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简写用下划线</span></span><br><span class="line">scala&gt; list.map(_*<span class="number">10</span>)</span><br><span class="line">res23: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure><h3 id="扁平化映射-flatmap"><a href="#扁平化映射-flatmap" class="headerlink" title="扁平化映射 - flatmap"></a>扁平化映射 - flatmap</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: (<span class="type">A</span>) ⇒ <span class="type">GenTraversableOnce</span>[<span class="type">B</span>]): <span class="type">TraversableOnce</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>flatmap方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>泛型</td><td>[B]</td><td>最终要转换的集合元素类型</td></tr><tr><td>参数</td><td>f: (A) ⇒ GenTraversableOnce[B]</td><td>传入一个函数对象<br>函数的参数是集合的元素<br>函数的返回值是一个集合</td></tr><tr><td>返回值</td><td>TraversableOnce[B]</td><td>B类型的集合</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个List集合,每一个元素中就是一行数据，有很多个单词</span></span><br><span class="line">scala&gt;  <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">"hadoop hive spark flink"</span>, <span class="string">"hbase spark"</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(hadoop hive spark flink, hbase spark)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用flatMap进行扁平化处理，获取得到所有的单词</span></span><br><span class="line">scala&gt; list.flatMap(x =&gt; x.split(<span class="string">" "</span>))</span><br><span class="line">res24: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(hadoop, hive, spark, flink, hbase, spark)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">scala&gt; list.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">res25: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(hadoop, hive, spark, flink, hbase, spark)</span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMap该方法其本质是先进行了map 然后又调用了flatten</span></span><br><span class="line">scala&gt; list.map(_.split(<span class="string">" "</span>)).flatten</span><br><span class="line">res26: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(hadoop, hive, spark, flink, hbase, spark)</span><br></pre></td></tr></table></figure><h3 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤 - filter"></a>过滤 - filter</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: (<span class="type">A</span>) ⇒ <span class="type">Boolean</span>): <span class="type">TraversableOnce</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>filter方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>参数</td><td>p: (A) ⇒ Boolean</td><td>传入一个函数对象<br>接收一个集合类型的参数<br>返回布尔类型，满足条件返回true, 不满足返回false</td></tr><tr><td>返回值</td><td>TraversableOnce[A]</td><td>列表</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个list集合</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤出集合中大于5的元素</span></span><br><span class="line">scala&gt; list.filter(x =&gt; x&gt;<span class="number">5</span>)</span><br><span class="line">res27: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//把集合中大于5的元素取出来乘以10生成一个新的list集合</span></span><br><span class="line">scala&gt; list.filter(_ &gt; <span class="number">5</span>).map(_ * <span class="number">10</span>)</span><br><span class="line">res29: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 - sort"></a>排序 - sort</h3><p>在scala集合中，可以使用以下几种方式来进行排序</p><ul><li>sorted默认排序 </li><li>sortBy指定字段排序 </li><li>sortWith自定义排序</li></ul><h4 id="sorted默认排序"><a href="#sorted默认排序" class="headerlink" title="sorted默认排序"></a>sorted默认排序</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个List集合</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list=<span class="type">List</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认就是升序</span></span><br><span class="line">scala&gt; list.sorted</span><br><span class="line">res30: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="sortBy指定字段排序"><a href="#sortBy指定字段排序" class="headerlink" title="sortBy指定字段排序"></a>sortBy指定字段排序</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBy</span></span>[<span class="type">B</span>](f: (<span class="type">A</span>) ⇒ <span class="type">B</span>): <span class="type">List</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>sortBy方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>泛型</td><td>[B]</td><td>按照什么类型来进行排序</td></tr><tr><td>参数</td><td>f: (A) ⇒ B</td><td>传入函数对象<br>接收一个集合类型的元素参数<br>返回B类型的元素进行排序</td></tr><tr><td>返回值</td><td>List[A]</td><td>返回排序后的列表</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个List集合</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> list=<span class="type">List</span>(<span class="string">"1 hadoop"</span>,<span class="string">"2 spark"</span>,<span class="string">"3 flink"</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="number">1</span> hadoop, <span class="number">2</span> spark, <span class="number">3</span> flink)</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照单词的首字母进行排序</span></span><br><span class="line">scala&gt; list.sortBy(x=&gt;x.split(<span class="string">" "</span>)(<span class="number">1</span>))</span><br><span class="line">res33: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="number">3</span> flink, <span class="number">1</span> hadoop, <span class="number">2</span> spark)</span><br></pre></td></tr></table></figure><h4 id="sortWith自定义排序"><a href="#sortWith自定义排序" class="headerlink" title="sortWith自定义排序"></a>sortWith自定义排序</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortWith</span></span>(lt: (<span class="type">A</span>, <span class="type">A</span>) ⇒ <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>sortWith方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>参数</td><td>lt: (A, A) ⇒ Boolean</td><td>传入一个比较大小的函数对象<br>接收两个集合类型的元素参数<br>返回两个元素大小，小于返回true，大于返回false</td></tr><tr><td>返回值</td><td>List[A]</td><td>返回排序后的列表</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">a: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">scala&gt; list.sortWith((x,y)=&gt;x&gt;y)</span><br><span class="line">res35: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line">scala&gt; list.sortWith((x,y)=&gt;x&lt;y)</span><br><span class="line">res36: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="分组-groupBy"><a href="#分组-groupBy" class="headerlink" title="分组 - groupBy"></a>分组 - groupBy</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](f: (<span class="type">A</span>) ⇒ <span class="type">K</span>): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">List</span>[<span class="type">A</span>]]</span><br></pre></td></tr></table></figure><table><thead><tr><th>groupBy方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>泛型</td><td>[K]</td><td>分组字段的类型</td></tr><tr><td>参数</td><td>f: (A) ⇒ K</td><td>传入一个函数对象<br>接收集合元素类型的参数<br>返回一个K类型的key，这个key会用来进行分组，相同的key放在一组中</td></tr><tr><td>返回值</td><td>Map[K, List[A]]</td><td>返回一个映射，K为分组字段，List为这个分组字段对应的一组数据</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="string">"张三"</span>-&gt;<span class="string">"男"</span>, <span class="string">"李四"</span>-&gt;<span class="string">"女"</span>, <span class="string">"王五"</span>-&gt;<span class="string">"男"</span>)</span><br><span class="line">a: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">List</span>((张三,男), (李四,女), (王五,男))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照性别分组</span></span><br><span class="line">scala&gt; a.groupBy(_._2)</span><br><span class="line">res0: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">List</span>[(<span class="type">String</span>, <span class="type">String</span>)]] = <span class="type">Map</span>(男 -&gt; <span class="type">List</span>((张三,男), (王五,男)),</span><br><span class="line">女 -&gt; <span class="type">List</span>((李四,女)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将分组后的映射转换为性别/人数元组列表</span></span><br><span class="line">scala&gt; res0.map(x =&gt; x._1 -&gt; x._2.size)</span><br><span class="line">res3: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(男 -&gt; <span class="number">2</span>, 女 -&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="聚合-reduce"><a href="#聚合-reduce" class="headerlink" title="聚合 - reduce"></a>聚合 - reduce</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](op: (<span class="type">A1</span>, <span class="type">A1</span>) ⇒ <span class="type">A1</span>): <span class="type">A1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>reduce方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>泛型</td><td>[A1 &gt;: A]</td><td>（下界）A1必须是集合元素类型的子类</td></tr><tr><td>参数</td><td>op: (A1, A1) ⇒ A1</td><td>传入函数对象，用来不断进行聚合操作<br>第一个A1类型参数为：当前聚合后的变量<br>第二个A1类型参数为：当前要进行聚合的元素</td></tr><tr><td>返回值</td><td>A1</td><td>列表最终聚合为一个元素</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">a: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; a.reduce((x,y) =&gt; x + y)</span><br><span class="line">res5: <span class="type">Int</span> = <span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个下划线表示第一个参数，就是历史的聚合数据结果</span></span><br><span class="line"><span class="comment">// 第二个下划线表示第二个参数，就是当前要聚合的数据元素</span></span><br><span class="line">scala&gt; a.reduce(_ + _)</span><br><span class="line">res53: <span class="type">Int</span> = <span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与reduce一样，从左往右计算</span></span><br><span class="line">scala&gt; a.reduceLeft(_ + _)</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右往左聚合计算</span></span><br><span class="line">scala&gt; a.reduceRight(_ + _)</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">55</span></span><br></pre></td></tr></table></figure><h3 id="折叠-fold"><a href="#折叠-fold" class="headerlink" title="折叠 - fold"></a>折叠 - fold</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) ⇒ <span class="type">A1</span>): <span class="type">A1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>reduce方法</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>泛型</td><td>[A1 &gt;: A]</td><td>（下界）A1必须是集合元素类型的子类</td></tr><tr><td>参数1</td><td>z: A1</td><td>初始值</td></tr><tr><td>参数2</td><td>op: (A1, A1) ⇒ A1</td><td>传入函数对象，用来不断进行折叠操作<br>第一个A1类型参数为：当前折叠后的变量<br>第二个A1类型参数为：当前要进行折叠的元素</td></tr><tr><td>返回值</td><td>A1</td><td>列表最终折叠为一个元素</td></tr></tbody></table><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个List集合</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">a: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">scala&gt; a.sum</span><br><span class="line">res41: <span class="type">Int</span> = <span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个初始值，，折叠求和</span></span><br><span class="line">scala&gt; a.fold(<span class="number">0</span>)(_+_)</span><br><span class="line">res42: <span class="type">Int</span> = <span class="number">55</span></span><br><span class="line"></span><br><span class="line">scala&gt; a.fold(<span class="number">10</span>)(_+_)</span><br><span class="line">res43: <span class="type">Int</span> = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从左往右</span></span><br><span class="line">scala&gt; a.foldLeft(<span class="number">10</span>)(_+_)</span><br><span class="line">res44: <span class="type">Int</span> = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从右往左</span></span><br><span class="line">scala&gt; a.foldRight(<span class="number">10</span>)(_+_)</span><br><span class="line">res45: <span class="type">Int</span> = <span class="number">65</span></span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>使用函数值作为参数，或者返回值为函数值的“函数”和“方法”，均称之为“高阶函数”</p><h4 id="函数值作为参数"><a href="#函数值作为参数" class="headerlink" title="函数值作为参数"></a>函数值作为参数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> array=<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> func=(x:<span class="type">Int</span>)=&gt;x*<span class="number">10</span></span><br><span class="line">func: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为参数传递到方法中</span></span><br><span class="line">scala&gt; array.map(func)</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个没有名称的函数----匿名函数</span></span><br><span class="line">scala&gt; array.map(x=&gt;x*<span class="number">10</span>)</span><br><span class="line">res1: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>方法可以定义多个参数列表，当使用较少的参数列表调用多参数列表的方法时，会产生一个新的函数，该函数接收剩余的参数列表作为其参数。这被称为<strong>柯里化</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAddress</span></span>(a:<span class="type">String</span>):(<span class="type">String</span>,<span class="type">String</span>)=&gt;<span class="type">String</span>=&#123;</span><br><span class="line">    (b:<span class="type">String</span>,c:<span class="type">String</span>)=&gt;a+<span class="string">"-"</span>+b+<span class="string">"-"</span>+c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> f1 = getAddress(<span class="string">"china"</span>)</span><br><span class="line">f1: (<span class="type">String</span>, <span class="type">String</span>) =&gt; <span class="type">String</span> = &lt;function2&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; f1(<span class="string">"beijing"</span>,<span class="string">"tiananmen"</span>)</span><br><span class="line">res5: <span class="type">String</span> = china-beijing-tiananmen</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里就可以这样去定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAddress</span></span>(a:<span class="type">String</span>)(b:<span class="type">String</span>,c:<span class="type">String</span>):<span class="type">String</span>=&#123; </span><br><span class="line">  a+<span class="string">"-"</span>+b+<span class="string">"-"</span>+c </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">scala&gt; getAddress(<span class="string">"china"</span>)(<span class="string">"beijing"</span>,<span class="string">"tiananmen"</span>)</span><br><span class="line">res0: <span class="type">String</span> = china-beijing-tiananmen</span><br><span class="line"></span><br><span class="line"><span class="comment">//之前使用的下面这些操作就是使用到了柯里化</span></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).fold(<span class="number">0</span>)(_+_)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).foldLeft(<span class="number">0</span>)(_+_)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).foldRight(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>函数里面引用外面类成员变量叫作闭包</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factor=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1=(x:<span class="type">Int</span>) =&gt; x*factor</span><br></pre></td></tr></table></figure><blockquote><p>定义的函数f1，它的返回值是依赖于不在函数作用域的一个变量</p><p>后期必须要要获取到这个变量才能执行</p><p>spark和flink程序的开发中大量的使用到函数，函数的返回值依赖的变量可能都需要进行大量的网络传</p><p>输获取得到，这里就需要这些变量实现序列化进行网络传输。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scala-函数式编程&quot;&gt;&lt;a href=&quot;#Scala-函数式编程&quot; class=&quot;headerlink&quot; title=&quot;Scala 函数式编程&quot;&gt;&lt;/a&gt;Scala 函数式编程&lt;/h1&gt;&lt;h3 id=&quot;遍历-foreach&quot;&gt;&lt;a href=&quot;#遍历-fore
      
    
    </summary>
    
    
    
      <category term="Scala" scheme="https://github.com/linlinnn/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引</title>
    <link href="https://github.com/linlinnn/2020/04/11/MySQL%20%E7%B4%A2%E5%BC%95/"/>
    <id>https://github.com/linlinnn/2020/04/11/MySQL%20%E7%B4%A2%E5%BC%95/</id>
    <published>2020-04-11T15:08:26.369Z</published>
    <updated>2020-04-11T15:12:02.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><h4 id="索引的基本评估思路"><a href="#索引的基本评估思路" class="headerlink" title="索引的基本评估思路"></a>索引的基本评估思路</h4><p>B+树</p><p>页大小：16KB</p><p>如何计算对应树的高度，表能存放的记录数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show table status like &#39;table_a&#39;;</span><br><span class="line"># 参考对应的avg_row_length</span><br></pre></td></tr></table></figure><p>现在假设主键为10个字节，每条记录平均500字节</p><p>聚簇索引，记录存放在叶子节点</p><table><thead><tr><th>树的高度</th><th>记录数</th></tr></thead><tbody><tr><td>1</td><td>32</td></tr><tr><td>2</td><td>1000 * 32 = 32000</td></tr><tr><td>3</td><td>1000^2 * 32 = 32000000</td></tr></tbody></table><blockquote><p>MySQL 数据量级为千万级别的时候，一般能有比较不错的查询性能</p><p>当然这是理论值，因为会有碎片的存在，可以乘以70%作为合理预估</p></blockquote><p>IOPS = 1000ms / (寻道时间 + 旋转延迟)</p><p>磁盘的IOPS大约为100，所以一个树高为3的查询时间可预估为3 / 100 = 0.03 s</p><h4 id="查看索引信息"><a href="#查看索引信息" class="headerlink" title="查看索引信息"></a>查看索引信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from table_a</span><br></pre></td></tr></table></figure><p><code>Cardinality</code> 是一个比较重要的指标，表示不重复值的个数（采样预估，具体采样页数可以控制），这个值越大越好，用来衡量索引区分数据的能力</p><p>如果是复合索引，则后面的Cardinality表示的是和前面的sequence的列组合起来的区分度</p><p>即seq为1，表示一个列的区分度，seq为2，表示1和2列组合起来的区分度</p><blockquote><p>思考：索引应该创建在区分度比较高的列，那么类别需不需要加索引？</p><p>一般而言，类别的种类不会很多，所以区分度并不高，那么为了支持类别的查询，可以考虑使用分区的方式</p></blockquote><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>由多个列组成的索引，最重要的就是最左前缀原则</p><p>索引能进行快速定位数据的原理是，对组成索引的列进行了排序</p><p>假设table_a有复合索引(a, b)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 可以使用索引</span><br><span class="line">select * from table_a where a &#x3D; ?</span><br><span class="line"># 可以使用索引</span><br><span class="line">select * from table_a where a &#x3D; ? and b &#x3D; ?</span><br><span class="line"># 不可以使用索引</span><br><span class="line">select * from table_a where b &#x3D; ?</span><br><span class="line"># 不可以使用索引</span><br><span class="line">select * from table_a where a &#x3D; ? or b &#x3D; ?</span><br><span class="line"># 先使用索引a得到一部分数据，再用b &#x3D; ?进行过滤</span><br><span class="line">select * from table_a where a &gt; ? and b &#x3D; ?</span><br><span class="line"># 可以使用覆盖索引</span><br><span class="line">select count(1) from table_a where b &gt; ? and b &lt; ?</span><br></pre></td></tr></table></figure><p>假设table_a有复合索引(a, b, c)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 先使用索引a得到一部分数据，再用c &#x3D; ?进行过滤</span><br><span class="line">select * from table_a where a &#x3D; ? and c &#x3D; ?</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-索引&quot;&gt;&lt;a href=&quot;#MySQL-索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL 索引&quot;&gt;&lt;/a&gt;MySQL 索引&lt;/h1&gt;&lt;h4 id=&quot;索引的基本评估思路&quot;&gt;&lt;a href=&quot;#索引的基本评估思路&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://github.com/linlinnn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据类型</title>
    <link href="https://github.com/linlinnn/2020/04/11/MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://github.com/linlinnn/2020/04/11/MySQL%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-04-11T15:08:26.348Z</published>
    <updated>2020-04-11T15:11:22.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h1><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table><thead><tr><th>Type</th><th>Storage (Bytes)</th><th>Minimum Value Signed</th><th>Minimum Value Unsigned</th><th>Maximum Value Signed</th><th>Maximum Value Unsigned</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128</td><td>0</td><td>127</td><td>255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768</td><td>0</td><td>32767</td><td>65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608</td><td>0</td><td>8388607</td><td>16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648</td><td>0</td><td>2147483647</td><td>4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-2^63</td><td>0</td><td>2^63-1</td><td>2^64-1</td></tr></tbody></table><blockquote><p>自增主键推荐使用bigint</p><p>int类型推荐使用默认signed，一则数据量级不足可选择bigint，二则避免小-大会越界的问题</p><p>整数类型的(N)，N表示的和数字范围无关，如果使用zerofill的话，不足的位会填0</p></blockquote><h4 id="定点型（精确数字型）"><a href="#定点型（精确数字型）" class="headerlink" title="定点型（精确数字型）"></a>定点型（精确数字型）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salary DECIMAL(5,2)</span><br><span class="line">#-999.99 to 999.99</span><br></pre></td></tr></table></figure><blockquote><p> maximum number of digits for DECIMAL is 65，默认是DECIMAL(10, 0)</p><p> 16位就已经到千兆级别了，所以定义金钱类型可以使用DECIMAL，注意小数点scale范围不够是会截断四舍五入的，金钱类型到分，毫就已经完全够了，DECIMAL(18, 3)，就是百兆，可精确到毫，一般而言都够用了</p></blockquote><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>MySQL uses four bytes for single-precision values and eight bytes for double-precision values.</p><p><strong>FLOAT(M,D)</strong> - 不能使用无符号的浮点数字。可以定义显示长度(M)和小数位数(D)。这不是必需的，并且默认为10,2。其中2是小数的位数，10是数字(包括小数)的总数。小数精度可以到24个浮点。</p><p>*<em>DOUBLE(M,D) *</em>- 不能使用无符号的双精度浮点数。可以定义显示长度(M)和小数位数(D)。 这不是必需的，默认为16,4，其中4是小数的位数。小数精度可以达到53位的DOUBLE。 REAL是DOUBLE同义词。</p><blockquote><p>For example, a column defined as   FLOAT(7,4) will look like    -999.9999 when displayed. MySQL performs rounding when storing values, so if you insert   999.00009 into a  FLOAT(7,4) column, the approximate result is  999.0001.</p></blockquote><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><table><thead><tr><th>Data Type</th><th>“Zero” Value</th><th>Storage (Bytes)</th><th>Time Range</th></tr></thead><tbody><tr><td>DATE</td><td>0000-00-00</td><td>3</td><td>1000-01-01 to 9999-12-31</td></tr><tr><td>TIME</td><td>00:00:00</td><td></td><td>-838:59:59 to 838:59:59</td></tr><tr><td>DATETIME</td><td>0000-00-00 00:00:00</td><td>8</td><td>1000-01-01 00:00:00 to 9999-12-31        23:59:59</td></tr><tr><td>TIMESTAMP</td><td>0000-00-00 00:00:00</td><td>4</td><td>1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC</td></tr><tr><td>YEAR</td><td>0000</td><td>1</td><td>1901 to 2155</td></tr></tbody></table><blockquote><p>现在都2020年了，不晓得TIMESTAMP以后咋整，然后TIMESTAMP的特点是有时区特性</p><p>DATE 具体到天，DATETIME/ TIMESTAMP/ TIME 可具体到6位小数点（微秒）</p></blockquote><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><table><thead><tr><th>Value</th><th>CHAR(4)</th><th>Storage Required</th><th>VARCHAR(4)</th><th>Storage Required</th></tr></thead><tbody><tr><td>‘’</td><td>‘    ‘</td><td>4 bytes</td><td>‘’</td><td>1 byte</td></tr><tr><td>‘ab’</td><td>‘ab  ‘</td><td>4 bytes</td><td>‘ab’</td><td>3 bytes</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr><tr><td>‘abcdefgh’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr></tbody></table><blockquote><p>CHAR类型定长会使用空格进行填充</p><p>VARCHAR类型不定长</p><p>其他字符类存储的是二进制</p></blockquote><h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><ul><li>开启严格的sql_mode，避免一些非法插入</li><li>字符集选用utf8mb4，utf8是它的子集，扩充了一些移动端的字符</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-数据类型&quot;&gt;&lt;a href=&quot;#MySQL-数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据类型&quot;&gt;&lt;/a&gt;MySQL 数据类型&lt;/h1&gt;&lt;h4 id=&quot;整型&quot;&gt;&lt;a href=&quot;#整型&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://github.com/linlinnn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL命令</title>
    <link href="https://github.com/linlinnn/2020/04/11/MySQL%20%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/linlinnn/2020/04/11/MySQL%20%E5%91%BD%E4%BB%A4/</id>
    <published>2020-04-11T15:08:26.335Z</published>
    <updated>2020-04-11T15:10:53.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL命令"><a href="#MySQL命令" class="headerlink" title="MySQL命令"></a>MySQL命令</h1><h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><h5 id="创建-删除账号"><a href="#创建-删除账号" class="headerlink" title="创建/删除账号"></a>创建/删除账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user &#39;app&#39;@&#39;127.0.0.1&#39;;</span><br><span class="line">drop user &#39;app&#39;@&#39;127.0.0.1&#39;;</span><br></pre></td></tr></table></figure><h5 id="授予-回收权限"><a href="#授予-回收权限" class="headerlink" title="授予/回收权限"></a>授予/回收权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select on user.table1 to &#39;app&#39;@&#39;127.0.0.1&#39;;</span><br><span class="line">revoke select on user.table1 to &#39;app&#39;@&#39;127.0.0.1&#39;;</span><br></pre></td></tr></table></figure><h5 id="代理（实现组管理）"><a href="#代理（实现组管理）" class="headerlink" title="代理（实现组管理）"></a>代理（实现组管理）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant proxy on &#39;dba&#39;@&#39;127.0.0.1&#39; to &#39;app&#39;@&#39;127.0.0.1&#39;;</span><br><span class="line">grant select on user.table1 to &#39;dba&#39;@&#39;127.0.0.1&#39;;</span><br></pre></td></tr></table></figure><h5 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#39;dba&#39;@&#39;127.0.0.1&#39;;</span><br></pre></td></tr></table></figure><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><table><thead><tr><th>参数</th><th>说明</th><th>版本</th></tr></thead><tbody><tr><td>slow_query_log</td><td>是否开启慢查询日志</td><td></td></tr><tr><td>slow_query_log_file</td><td>慢查询日志文件名</td><td></td></tr><tr><td>long_query_time</td><td>慢查询阈值（大于）</td><td>5.5 支持毫秒</td></tr><tr><td>min_examined_row_limit</td><td>扫描记录少于该值的SQL不记录到慢查询日志</td><td></td></tr><tr><td>log_queries_not_using_indexes</td><td>没有使用索引的SQL记录</td><td></td></tr><tr><td>log_throttle_queries_not_using_indexes</td><td>限制每分钟记录没有使用索引的次数</td><td>5.6</td></tr><tr><td>log_slow_admin_statements</td><td>记录管理操作</td><td></td></tr><tr><td>log_output</td><td>慢查询日志格式（FILE|TABLE|NONE）</td><td>5.5</td></tr><tr><td>log_slow_slave_statements</td><td>从服务器上开启慢查询日志</td><td></td></tr><tr><td>log_timestamps</td><td>写入时区信息</td><td>5.7</td></tr></tbody></table><h5 id="参考配置"><a href="#参考配置" class="headerlink" title="参考配置"></a>参考配置</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = slow.log</span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_slow_admin_statements</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_slow_slave_statements</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_throttle_queries_not_using_indexes</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">90</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">min_examined_row_limit</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure><h5 id="格式化慢查询日志"><a href="#格式化慢查询日志" class="headerlink" title="格式化慢查询日志"></a>格式化慢查询日志</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow slow.log</span><br></pre></td></tr></table></figure><blockquote><p>如果慢查询日志文件比较大的话，可以截取出其中的一部分，如tail -10000f slow.log &gt; slow10000.log</p><p>因为一般来说这段时间的慢查询日志都是由于类似的查询语句产生的</p><p>也可以将慢查询日志存放到TABLE，mysql.slow_log，默认的存储引擎是CSV，先关闭改成myisam再开启</p><p>set global slow_query_log = 0;</p><p>alter table slow_log engine = myisam;</p><p>set global slow_query_log = 1;</p></blockquote><h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><h5 id="查看frm文件"><a href="#查看frm文件" class="headerlink" title="查看frm文件"></a>查看frm文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装mysql-utilities</span><br><span class="line">mysqlfrm --diagnostic xxx.frm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL命令&quot;&gt;&lt;a href=&quot;#MySQL命令&quot; class=&quot;headerlink&quot; title=&quot;MySQL命令&quot;&gt;&lt;/a&gt;MySQL命令&lt;/h1&gt;&lt;h4 id=&quot;用户权限&quot;&gt;&lt;a href=&quot;#用户权限&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://github.com/linlinnn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 存储引擎</title>
    <link href="https://github.com/linlinnn/2020/04/11/MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://github.com/linlinnn/2020/04/11/MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2020-04-11T15:08:26.305Z</published>
    <updated>2020-04-11T15:10:02.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><p>版本：5.7.11</p><h3 id="存储引擎的类别"><a href="#存储引擎的类别" class="headerlink" title="存储引擎的类别"></a>存储引擎的类别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select engines;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/04/11/MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/MySQL" alt="img" title="存储引擎/engines.JPG">                </div>                <div class="image-caption">存储引擎/engines.JPG</div>            </figure><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MySQL5.1版本之前（包括5.1）的默认存储引擎</p><ul><li>堆表数据结构</li><li>表锁设计</li><li>支持数据静态压缩</li><li>不支持事务</li><li>数据容易丢失</li><li>索引容易损坏（不保证数据文件和索引文件同步更新，写入到操作系统缓存，如果发生宕机或者磁盘空间满了）</li></ul><p>唯一的优点：数据文件可以直接拷贝到另一台服务器使用</p><h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p>以MySQL标准接口访问CSV文件</p><p>CSV所有的列都是NOT NULL</p><h4 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h4><p>允许本地访问远程MySQL数据库中表的数据</p><p>本地不存储任何数据文件</p><p>默认是关闭的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-存储引擎&quot;&gt;&lt;a href=&quot;#MySQL-存储引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL 存储引擎&quot;&gt;&lt;/a&gt;MySQL 存储引擎&lt;/h1&gt;&lt;p&gt;版本：5.7.11&lt;/p&gt;
&lt;h3 id=&quot;存储引擎的类别&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://github.com/linlinnn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>深入JVM之java内存模型</title>
    <link href="https://github.com/linlinnn/2020/03/09/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/linlinnn/2020/03/09/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-08T21:05:43.291Z</published>
    <updated>2020-03-08T21:08:27.297Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​    Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值的底层细节。</p><p>​    Java内存模型规定所有的变量存储在主内存中。每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本（不是复制整个对象，如对象的引用，对象中某个被线程访问到的字段），线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/memory-model.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>​    关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证这些操作是原子的，不可再分的。（double和long类型的变量有些特别，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行）</p><ul><li>lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li><li>unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中</li><li>load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值得字节码指令时执行这个操作</li><li>assign：作用于工作内存的变量，它把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中</li><li>write：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul><p>Java内存模型规定了在执行上述操作时必须满足如下规则：</p><ul><li>不允许read和load，store和write操作之一单独出现</li><li>变量在工作内存中改变了之后必须把该变化同步回主内存</li><li>不允许一个线程没有发生任何的assign操作就把工作内存同步回主内存</li><li>一个新的变量只能从主内存中“诞生”</li><li>一个变量同一时刻只能被一个线程lock，但同一个线程可以lock多次，然后执行相同次数的unlock才能释放</li><li>对一个变量执行lock，将清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值</li><li>一个变量没有lock就不能unlock，也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量unlock前，必须先把此变量同步回主内存中</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当一个变量被定义成volatile之后，它将具备两项特性：</p><ul><li>保证此变量对所有线程的可见性，“可行性”指的是当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，由于volatile只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性<ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul></li><li>禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的记过，而不能保证变量赋值操作的顺序与程序代码的执行顺序一致。</li></ul><h2 id="先行发生原则（Happens-Before）"><a href="#先行发生原则（Happens-Before）" class="headerlink" title="先行发生原则（Happens-Before）"></a>先行发生原则（Happens-Before）</h2><ul><li>程序次序规则：在一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作（区分时间先后顺序）</li><li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li><li>volatile规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li>线程启动规则：Thread的start先行发生于此线程的所有动作</li><li>线程终止规则：线程的所有操作都先行发生于此线程的终止检测</li><li>线程中断规则：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>对象终结规则：一个对象的初始化完成先行发生于它的finalize方法的开始</li><li>传递性：A先于B，B先于C，则A先于C</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深入JVM之java线程基础</title>
    <link href="https://github.com/linlinnn/2020/03/08/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/linlinnn/2020/03/08/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-08T13:30:12.782Z</published>
    <updated>2020-03-08T13:33:36.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h2><ul><li>新建（New）：创建后未启动的线程</li><li>运行（Runnable）：正在执行或者正在等待操作系统为它分配执行时间</li><li>无限期等待（Waiting）：等待被其他线程显示唤醒<ul><li>Object::wait()</li><li>Thread::join()</li><li>LockSupport::park()</li></ul></li><li>限期等待（Timed Waiting）：一定时间后由系统自动唤醒<ul><li>Thread::sleep()</li><li>Object::wait(Timeout)</li><li>Thread::join(TImeout)</li><li>LockSupport::parkNanos()</li><li>LockSupport::parkUntil()</li></ul></li><li>阻塞（Blocked）：等待获取排它锁</li><li>结束（Terminated）：线程已经结束执行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/thread-status.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>内核线程的调度成本主要来自于用户态与核心态的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>​    <code>synchronized</code>持有锁是一个重量级的操作，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统帮忙完成，这就不可避免地陷入用户态到核心的转换，进行这种状态转换需要耗费很多的处理器时间</p><p>​    除了synchronized关键字外，自JDK5，基于Lock接口，用户能够以非块结构来实现互斥同步</p><p>​    重入锁<code>ReentrantLock</code> 是Lock接口的一种实现，它与synchronized很相似，相比增加了一些高级功能，主要由三项：等待可中断、可实现公平锁及锁可以绑定多个条件：</p><ul><li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助</li><li>公平锁：多个线程等待同一个锁时，必须按照申请锁的时间顺序来依次获取锁，而非公平锁不保证这一点，使用非公平锁，将会导致<code>ReentrantLock</code> 性能急剧下降，影响吞吐量</li><li>锁绑定多个条件：可以同时绑定多个<code>Condition</code> 对象</li></ul><blockquote><p><code>synchronized</code>和<code>ReentrantLock</code> 都能够满足需求时，推荐使用synchronized</p><ol><li>同步地语义更加清晰</li><li>Lock需要对应finally-unlock，但是synchronized会保证释放锁</li><li>Lock和synchronized目前性能差不多，不过synchronized将来有更多的优化空间</li></ol></blockquote><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>​    互斥同步是一种悲观的并发策略（实际上虚拟机会优化掉很大一部分不必要的加锁），另一个选择是基于冲突检测的乐观并发策略，乐观并发策略需要“硬件指令集的发展”，因为要求操作和冲突检测这两个步骤具备原子性，这类指令常用的有：</p><ul><li><p>测试并设置（Test-and-Set）</p></li><li><p>获取并增加（Fetch-and-Increment）</p></li><li><p>交换（Swap）</p></li><li><p>比较并交换（Compare-and-Swap）</p></li><li><p>加载链接/条件储存（Load-Linked/Store-Conditonal）</p><p>CAS指令需要三个操作数，分别是内存位置、旧的预期值、准备设置的新值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="comment">// unsafe.getAndAddInt(this, valueOffset, 1) + 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无限循环中，不断尝试将一个比当前值大一的新值赋值给自己，如果失败了，则说明旧值已经发生变化</p><p>ABA问题，可以通过一个带有标记原子引用类<code>AtomicStampedReference</code>， 大部分情况下ABA问题不会影响程序并发的正确性，如果要解决ABA问题，改为互斥同步可能会比原子类更为高效</p></blockquote></li></ul><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>线程本地存储（Thread Local Storage），每个线程持有一份变量副本，消除竞争关系</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>​    现在的物理机器普通都是多核处理器系统，能够让两个或以上的能够同时并行执行，可以让后面请求锁的那个线程“稍等一会”，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需让线程执行一个忙循环（自旋），这项技术就是自旋锁</p><p>​    自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就好，反之则只会白白消耗处理器资源。因此自旋等待必须有一定的时间限制，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式挂起线程。默认值是十次，-XX:PreBlockSpin设置</p><p>​    不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在JDK6中对自旋锁的优化，引入了自适应的自旋，由前一次在同一个锁的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在进行中，那么虚拟机就会认为这个自旋也很有可能再次成功，进而允许自旋等待持续更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那么以后就有可能忽略掉自旋的过程，直接挂起</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>​    锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除，主要依据是逃逸分析的数据支持。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>​    虚拟机检测到一串操作都对同一对象的加锁，放大加锁的范围到整个操作序列的外部</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>​    在<code>没有多线程竞争</code>的前提下（大部分的锁，在整个同步周期内都不存在竞争），减少传统的重量级锁使用操作系统互斥量产生的性能消耗</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E6%B7%B1%E5%85%A5JVM%E4%B9%8Bjava%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/mark-word.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>​    消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即对比轻量级锁连CAS操作都省去</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java线程&quot;&gt;&lt;a href=&quot;#Java线程&quot; class=&quot;headerlink&quot; title=&quot;Java线程&quot;&gt;&lt;/a&gt;Java线程&lt;/h1&gt;&lt;h2 id=&quot;Java线程状态&quot;&gt;&lt;a href=&quot;#Java线程状态&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
      <category term="深入JVM" scheme="https://github.com/linlinnn/tags/%E6%B7%B1%E5%85%A5JVM/"/>
    
  </entry>
  
  <entry>
    <title>网络通信之TCP</title>
    <link href="https://github.com/linlinnn/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/"/>
    <id>https://github.com/linlinnn/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/</id>
    <published>2020-03-08T13:20:52.339Z</published>
    <updated>2020-03-08T13:29:06.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络通信之TCP"><a href="#网络通信之TCP" class="headerlink" title="网络通信之TCP"></a>网络通信之TCP</h2><h3 id="1-1、简介："><a href="#1-1、简介：" class="headerlink" title="1.1、简介："></a>1.1、简介：</h3><ul><li>面向<strong>连接的、可靠的、基于字节流</strong>的<strong>传输层通信协议</strong></li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层，数据包都有序号，对方收到则发送ACK确认，<strong>保证有序接收、重复报文自动废弃、未收到则重传</strong></li><li>使用<strong>奇偶校验和</strong>来检验数据在传输过程中是否有误</li><li>双向传递（全双工）</li><li>流量缓冲：解决速度不匹配问题</li><li>拥塞控制</li></ul><h3 id="1-2、TCP报文"><a href="#1-2、TCP报文" class="headerlink" title="1.2、TCP报文"></a>1.2、TCP报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>TCP Flags</strong></p><p><strong>ACK</strong>: 确认序号标志</p><p><strong>SYN</strong>: 请求连接标志</p><p><strong>FIN</strong>: 释放连接标志</p><p><strong>PSH</strong>:数据传输标志</p></blockquote><h3 id="1-3、三次握手"><a href="#1-3、三次握手" class="headerlink" title="1.3、三次握手"></a>1.3、三次握手</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="1-3-1、SYN报文"><a href="#1-3-1、SYN报文" class="headerlink" title="1.3.1、SYN报文"></a>1.3.1、SYN报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>第一次握手：SYN=1，随机生成seq序号989512128（）</p><p>Client 状态：<code>CLOSED</code>  =&gt; <code>SYN_SENT</code></p><p>Server状态：<code>LISTEN</code>  =&gt; <code>SYN_REVD</code></p><h3 id="1-3-2、SYN-ACK报文"><a href="#1-3-2、SYN-ACK报文" class="headerlink" title="1.3.2、SYN/ACK报文"></a>1.3.2、SYN/ACK报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-synack.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>第二次握手：SYN=1，ACK=1, ack=seq+1=989512129, 随机生成seq序号753743756</p><p>Client 状态：<code>SYN_SENT</code> =&gt; <code>ESTALISHED</code></p><h3 id="1-3-3、ACK报文"><a href="#1-3-3、ACK报文" class="headerlink" title="1.3.3、ACK报文"></a>1.3.3、ACK报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-ack.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>第三次握手：ACK=1，ack=seq+1=753743757</p><p>Server状态：<code>SYN_REVD</code> =&gt; <code>ESTABLISHED</code>，成功建立连接，可以开始数据传输</p><blockquote><p>为什么两次握手不可以？</p><p>假设是两次握手，客户端发送了<code>SYN报文1</code>，但没有收到SYN/ACK报文，以为报文丢失，重新发送<code>SYN报文2</code>，此时连接建立然后关闭，但<code>SYN报文1</code> 此时到达了服务端，再次建立连接，导致错误连接和资源浪费。</p><p>而三次握手即使服务端收到了失效的<code>SYN报文1</code> ，由于客户端不会发送ACK报文，此时服务端收不到ACK报文，就不会建立连接</p></blockquote><h3 id="1-3-4、PSH-ACK报文"><a href="#1-3-4、PSH-ACK报文" class="headerlink" title="1.3.4、PSH/ACK报文"></a>1.3.4、PSH/ACK报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-pshack.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>ACK=1，PSH=1，开始传输数据，数据长度为285</p><h3 id="1-3-5、ACK报文"><a href="#1-3-5、ACK报文" class="headerlink" title="1.3.5、ACK报文"></a>1.3.5、ACK报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-rec.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>ACK=1，ack=seq+len=989512129+285=989512414</p><h3 id="1-4、SYN攻击"><a href="#1-4、SYN攻击" class="headerlink" title="1.4、SYN攻击"></a>1.4、SYN攻击</h3><p>​    攻击者短时间伪造不同IP地址的SYN报文，快速占满backlog队列，服务器端的连接都处于SYN_RECEIVED的状态，占用大量的资源，使得正常的连接无法建立。</p><ul><li>net.core.netdev_max_backlog<ul><li>接受自网卡、但未被内核协议栈处理的报文队列长度</li></ul></li><li>net.ipv4.tcp_max_syn<ul><li>SYN_RCVD状态连接的最大个数</li></ul></li><li>net.ipv4.tcp_abort_on_overflow<ul><li>超出处理能力时，对新来的SYN直接回包RST，丢弃连接</li></ul></li><li>net.ipv4.tcp_syncookies = 1<ul><li>当SYN队列满后，新的SYN不进入队列，计算出cookie再以SYN+ACK的序列号返回客户端，正常客户端发报文时，服务器根据报文中携带的cookie重新恢复连接<ul><li>由于cookie占用序列号空间，导致此时所有TCP可选功能失效</li></ul></li></ul></li></ul><h3 id="1-4、三次握手优化"><a href="#1-4、三次握手优化" class="headerlink" title="1.4、三次握手优化"></a>1.4、三次握手优化</h3><h4 id="1-4-1、操作系统内核限制调整"><a href="#1-4-1、操作系统内核限制调整" class="headerlink" title="1.4.1、操作系统内核限制调整"></a>1.4.1、操作系统内核限制调整</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-adv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在操作系统内核中分别用SYN队列和ACCEPT队列来维护相应的连接套接字</p><p>当连接数非常多的时候可以对操作系统内核限制进行调整</p><ul><li>服务器端SYN_RCV状态<ul><li>net.ipv4.tcp_max_syn_backlog：SYN_RCVD状态连接的最大个数</li><li>net.ipv4.tcp_synack_retries：被动建立连接时，发SYN/ACK的重试次数</li></ul></li><li>客户端SYN_SENT状态<ul><li>net.ipv4.tcp_syn_retries = 6 主动建立连接时，发SYN的重试次数</li><li>net.ipv4.ip_local_port_range = 32768 ~ 60999 建立连接时的本地端口可用范围</li></ul></li><li>ACCEPT队列设置</li><li>TCP_DEFER_ACCEPT：当有数据报文时操作系统内核才激活应用程序</li></ul><h4 id="1-4-2、Fast-Open-降低时延"><a href="#1-4-2、Fast-Open-降低时延" class="headerlink" title="1.4.2、Fast Open 降低时延"></a>1.4.2、Fast Open 降低时延</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-fastopen.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>每一次TCP连接数据传输都需要2*RTT时间</p><ul><li>TCP协议提供了Fast Open方式，服务器将第一次建立连接成功的相关信息保存在Cookie缓存在客户端中，客户端后续请求建立连接通过携带这个Cookie消除了三次握手，使得只需要1*RTT的时间，若Cookie丢失，则在RTO后发起普通的三次握手连接</li></ul><ul><li>Server校验Cookie（解密Cookie以及比对IP地址或者重新加密IP地址以和接收到的Cookie进行对比）。<ul><li>如果验证成功，向用户发送SYN+ACK，在用户回复ACK之前，便可以向用户传输数据；</li><li>如果验证失败，则丢弃此TFO请求携带的数据，回复SYN-ACK确认SYN Seq，完成正常的三次握手。</li></ul></li><li>建立了TFO连接而又没有完成TCP连接的请求在Server端被称为pending TFO connection，当pending的连接超过上限值，Server会关闭TFO，后续的请求会按正常的三次握手处理。</li><li>如果一个带有TFO的SYN请求如果在一段时间内没有收到回应，用户会重新发送一个标准的SYN请求，不带</li></ul><p>任何其他数据。</p><p>Linux上打开TCP Fast Open</p><ul><li>net.ipv4.tcp_fastopen：系统开启TFP功能<ul><li>0： 关闭</li><li>1：作为客户端时可以使用TFO</li><li>2：作为服务器时可以使用TFO</li><li>3：无论作为客户端还是服务器，都可以使用TFO</li></ul></li></ul><h3 id="1-5、四次挥手"><a href="#1-5、四次挥手" class="headerlink" title="1.5、四次挥手"></a>1.5、四次挥手</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BTCP/tcp-close.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>为什么建立连接时三次握手，释放连接却需要四次挥手？</p><ol><li>客户端发送<strong>FIN报文</strong>表示客户端不再发送数据（<strong>FIN-WAIT-1</strong>状态），但可以接收数据，服务端也还可以发送数据</li><li>服务端发送<strong>ACK报文</strong>，进入<strong>FIN-WAIT-2</strong>状态，服务端进入<strong>CLOSE-WAIT</strong>状态</li><li>服务端将最后的数据发送完毕，发送<strong>FIN报文</strong>，进入<strong>LAST-ACK</strong>状态</li><li>客户端发送<strong>ACK报文</strong>， 进入<strong>TIME-WAIT</strong>状态，此时TCP连接还没有释放，必须经过<strong>2*MSL</strong>时间后，当客户端撤销相应的TCB后，才进入<strong>CLOSED</strong>状态</li><li>服务端只要受到客户端发出的确认，立即进入<strong>CLOSED</strong>状态，撤销TCB，结束TCP连接</li></ol><p>为什么客户端发送ACK报文后要等待2*MSL（Maximum Segment Lifetime）时间？</p><ol><li>保证客户端发送的ACK报文可以到达服务端，假设此报文丢失，服务端就会认为客户端没有接收到FIN报文，进行重发，客户端就可以在2<em>MSL时间内收到重发的报文，发送ACK报文，重新等待2</em>MSL时间</li><li>在2*MSL时间内产生的报文都会在网络中消失，防止新连接接收到就连接的请求报文</li></ol><p>大量的连接处于TIME_WAIT状态，导致部分客户端连接不上？</p><p>主要关注场景：<strong>服务端主动关闭</strong>连接，<strong>高并发短连接</strong></p><p>/etc/sysctl.conf -p让参数生效</p><p>/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。</p><ul><li>net.ipv4.tcp_tw_reuse = 1 <ul><li>表示<strong>开启重用</strong>。（客户端）允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</li><li>由于timestamp的存在，操作系统可以拒绝迟到的报文</li><li>net.ipv4.tcp_timestamps = 1</li></ul></li><li>net.ipv4.tcp_tw_recycle = 1 <ul><li>（客户端和服务端）表示开启TCP连接中TIME-WAIT sockets的<strong>快速回收</strong>，默认为0，表示关闭</li><li>不安全，无法避免报文延迟、重复等给新连接造成混乱</li></ul></li><li>net.ipv4.tcp_fin_timeout <ul><li>修改默认的 TIMEOUT 时间</li></ul></li><li>net.ipv4.tcp_keepalive_time = 1200 <ul><li>表示当keepalive起用的时候，TCP发送keepalive消息的频度，缺省是2小时，改为20分钟</li></ul></li><li>net.ipv4.ip_local_port_range = 1024 65000 <ul><li>表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000</li></ul></li><li>net.ipv4.tcp_max_syn_backlog = 8192 <ul><li>表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</li></ul></li><li>net.ipv4.tcp_max_tw_buckets = 5000 <ul><li>表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息</li><li>默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死</li></ul></li></ul><p>大量连接处于CLOSE_WAIT状态</p><p>主要关注场景：一般是程序没有正常地释放资源导致</p><p>分析思路：</p><ol><li>出现问题后，立马应该检查日志，确实日志没有发现问题；</li><li>监控明确显示了socket不断增长，很明确立马应该使用 <code>netstat</code> 检查情况看看是哪个进程的锅；</li><li>根据 <code>netstat</code> 的检查，使用 <code>tcpdump</code> 抓包分析一下为什么连接会<strong>被动断开</strong>；</li><li>如果熟悉代码应该直接去检查业务代码，如果不熟悉则可以使用 <code>perf</code> 把代码的调用链路打印出来；</li><li>不论是分析代码还是火焰图，到此应该能够很快定位到问题。</li></ol><p>SO_REUSEADDR可以用在以下四种情况下。 (摘自《Unix网络编程》卷一)</p><p>1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。</p><p>2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。</p><p>3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。</p><p>4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</p><h3 id="1-6、滑动窗口（流量控制）"><a href="#1-6、滑动窗口（流量控制）" class="headerlink" title="1.6、滑动窗口（流量控制）"></a>1.6、滑动窗口（流量控制）</h3><p>1、通过一个最新ack序列号来确认在这之间的报文都以确认接收，丢包只需重发可发送窗口内ack序列号之后的报文。</p><p>2、接收方根据自己的处理情况返回下次发送多少个报文来控制滑动窗口大小，为避免该报文丢失，发送方会定时发送一个窗口探测报文。</p><h3 id="1-7、netstat命令查看TCP状态"><a href="#1-7、netstat命令查看TCP状态" class="headerlink" title="1.7、netstat命令查看TCP状态"></a>1.7、netstat命令查看TCP状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat </span><br><span class="line">-a 显示所有连接和监听端口</span><br><span class="line">-n 以数字形式（如IP地址）显示地址和端口号</span><br><span class="line">-r 显示路由表</span><br><span class="line">-s 显示每个协议的统计信息</span><br><span class="line">-o(Windows) 显示拥有的与每个连接关联的进程ID</span><br><span class="line">-b(Windows)/-p(Linux) 显示对应的可执行程序的名字</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络通信之TCP&quot;&gt;&lt;a href=&quot;#网络通信之TCP&quot; class=&quot;headerlink&quot; title=&quot;网络通信之TCP&quot;&gt;&lt;/a&gt;网络通信之TCP&lt;/h2&gt;&lt;h3 id=&quot;1-1、简介：&quot;&gt;&lt;a href=&quot;#1-1、简介：&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="网络通信" scheme="https://github.com/linlinnn/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码精进之路——读书笔记（1）</title>
    <link href="https://github.com/linlinnn/2020/03/08/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://github.com/linlinnn/2020/03/08/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2020-03-08T04:00:07.520Z</published>
    <updated>2020-03-08T11:08:48.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码精进之路——读书笔记（1）"><a href="#代码精进之路——读书笔记（1）" class="headerlink" title="代码精进之路——读书笔记（1）"></a>代码精进之路——读书笔记（1）</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>​    很多时候看到自己写代码或是别人写的代码就觉得要吐了，可是又很困惑该如何改进，想起一首rap，当我总是被这些问题给缠住，慢慢地想要克服它变成一种难度，周末的时候买了本新书《代码精进之路》，原来这是很多程序员都会遇到的情况，软件的复杂性是一个基本特征，再加上源源不断的需求压力总是使开发人员妥协，引发破窗效应，系统越来越混乱。故此记录下一些很有启发的理念。</p><h2 id="2、命名规范"><a href="#2、命名规范" class="headerlink" title="2、命名规范"></a>2、命名规范</h2><h3 id="2-1、代码注释"><a href="#2-1、代码注释" class="headerlink" title="2.1、代码注释"></a>2.1、代码注释</h3><p>​    如果注释是为了阐述代码背后的意图，那么这个注释是有意义的；</p><p>​    如果注释是为了复述代码功能，那么有可能就意味着代码的坏味道；</p><p>​    好的代码通过好的命名规范使得自身意图是显性化的，就如同看一篇说明文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复述代码功能：线程休眠2秒</span></span><br><span class="line"><span class="comment">// 阐述代码背后的意图：线程休眠2秒，为了等待相关系统处理结果</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码自释：不需要注释也能清楚获悉代码本意</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitProcessResultFromA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    LOGGER.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><h3 id="3-1、单一职责法则"><a href="#3-1、单一职责法则" class="headerlink" title="3.1、单一职责法则"></a>3.1、单一职责法则</h3><p>​    <code>SRP</code>（Single Responsibility Principle）单一职责法则，现阶段自身的系统抽象能力不足，还需要很多的经验和总结，但是将这一法则作用于函数是每个程序员都能够做到的，而将函数写好了，系统也会开始往好的方向衍进。</p><p>​    一个函数由命名、入参、出参组成，只要明确这三个点的意义，函数实现起来也会变得清晰，拿leetcode上一道简单题打个比方。</p><p>​    一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>​    以前遇到这种问题总是会陷入一种难以言喻的递归模拟，但其实函数的职责是很明确的，返回n级台阶的跳法</p><p>总数，入参为台阶级数，递归边界就是1级台阶只有1种跳法，2级台阶有两种跳法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数意义：台阶级数为floor层的跳法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">jumpWays</span><span class="params">(<span class="keyword">int</span> floor)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(floor &lt;= <span class="number">2</span>) <span class="keyword">return</span> floor;</span><br><span class="line">  <span class="comment">// 翻译一下递归就是，跳一级，也可以跳两级，返回总共的跳法</span></span><br><span class="line">  <span class="keyword">return</span> jumpWays(floor - <span class="number">1</span>) + jumpWays(floor - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当然还要对递归子问题使用记忆化进行优化。</p><p>​    这样就有一种感觉，写代码就是将需求以合适的方式复述出来，是一篇说明文。</p><h3 id="3-2、优化判空"><a href="#3-2、优化判空" class="headerlink" title="3.2、优化判空"></a>3.2、优化判空</h3><p>​    <code>NPE</code>(Null Pointer Exception)是需要时刻注意判断的，这就让要获取一些属性链路比较长的属性时经常写出这种令人呕吐的代码，可以使用Java 8的新特性<code>Optional</code> 进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了获取user里的isocode</span></span><br><span class="line"><span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">  Address address = user.getAddress();</span><br><span class="line">  <span class="keyword">if</span>(address != <span class="keyword">null</span>)&#123;</span><br><span class="line">      Country country = address.getCountry();</span><br><span class="line">      <span class="keyword">if</span>(country != <span class="keyword">null</span>)&#123;</span><br><span class="line">          String isocode = country.getIsocode();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比起大量的if语句，这样的链式调用更符合思维</span></span><br><span class="line">String isocode = Optional.ofNullable(user)</span><br><span class="line">  .flatMap(User::getAddress)</span><br><span class="line">  .flatMap(Address::getCountry)</span><br><span class="line">  .map(Country::getIsocode)</span><br><span class="line">  .orElse(<span class="string">"default"</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3、组合函数模式"><a href="#3-3、组合函数模式" class="headerlink" title="3.3、组合函数模式"></a>3.3、组合函数模式</h3><p>​    组合函数有助于代码保持精炼并易于复用，这样的代码就像一本很多说明文组成的书，入口函数是目录，目录的内容指向具体的私有函数。</p><p>​    <code>Spring</code>中<code>BeanUtils#copyProperties</code> 方法有57行，太长的函数容易让人迷失陷入细节，增大理解难度。当然细节是很重要的，只不过一次只关注一个点更利于提高效率，把握住重点，经过分析，这个函数主要做了两件事：一、判断能不能copy，二、执行copy。因此入口函数拆分为两个步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object dest, Object orig)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、checkDestAndOrig(dest, orig); 判断能不能copy</span></span><br><span class="line">    <span class="comment">// =========================================================</span></span><br><span class="line">    <span class="comment">// Validate existence of the specified beans</span></span><br><span class="line">    <span class="keyword">if</span> (dest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">                (<span class="string">"No destination bean specified"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (orig == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No origin bean specified"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"BeanUtils.copyProperties("</span> + dest + <span class="string">", "</span> +</span><br><span class="line">                  orig + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、copyOrigToDest(orig, dest); 执行copy，这段逻辑还是稍微长了，可以继续划分</span></span><br><span class="line">  <span class="comment">// =========================================================</span></span><br><span class="line">    <span class="comment">// Copy the properties, converting as necessary</span></span><br><span class="line">    <span class="keyword">if</span> (orig <span class="keyword">instanceof</span> DynaBean) &#123;</span><br><span class="line">        DynaProperty origDescriptors[] =</span><br><span class="line">            ((DynaBean) orig).getDynaClass().getDynaProperties();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origDescriptors.length; i++) &#123;</span><br><span class="line">            String name = origDescriptors[i].getName();</span><br><span class="line">            <span class="keyword">if</span> (getPropertyUtils().isWriteable(dest, name)) &#123;</span><br><span class="line">                Object value = ((DynaBean) orig).get(name);</span><br><span class="line">                copyProperty(dest, name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orig <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        Iterator names = ((Map) orig).keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (names.hasNext()) &#123;</span><br><span class="line">            String name = (String) names.next();</span><br><span class="line">            <span class="keyword">if</span> (getPropertyUtils().isWriteable(dest, name)) &#123;</span><br><span class="line">                Object value = ((Map) orig).get(name);</span><br><span class="line">                copyProperty(dest, name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">/* if (orig is a standard JavaBean) */</span> &#123;</span><br><span class="line">        PropertyDescriptor origDescriptors[] =</span><br><span class="line">            getPropertyUtils().getPropertyDescriptors(orig);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origDescriptors.length; i++) &#123;</span><br><span class="line">            String name = origDescriptors[i].getName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"class"</span>.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// No point in trying to set an object's class</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getPropertyUtils().isReadable(orig, name) &amp;&amp;</span><br><span class="line">                getPropertyUtils().isWriteable(dest, name)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object value =</span><br><span class="line">                        getPropertyUtils().getSimpleProperty(orig, name);</span><br><span class="line">                    copyProperty(dest, name, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    ; <span class="comment">// Should not happen</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    很多时候只要多做一点点，就可以写出更好的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码精进之路——读书笔记（1）&quot;&gt;&lt;a href=&quot;#代码精进之路——读书笔记（1）&quot; class=&quot;headerlink&quot; title=&quot;代码精进之路——读书笔记（1）&quot;&gt;&lt;/a&gt;代码精进之路——读书笔记（1）&lt;/h1&gt;&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="代码精进之路" scheme="https://github.com/linlinnn/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之ConcurrentHashMap</title>
    <link href="https://github.com/linlinnn/2020/02/27/Java%E6%BA%90%E7%A0%81%E4%B9%8BConcurrentHashMap/"/>
    <id>https://github.com/linlinnn/2020/02/27/Java%E6%BA%90%E7%A0%81%E4%B9%8BConcurrentHashMap/</id>
    <published>2020-02-27T14:49:23.769Z</published>
    <updated>2020-03-08T04:24:53.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java源码之ConcurrentHashMap"><a href="#Java源码之ConcurrentHashMap" class="headerlink" title="Java源码之ConcurrentHashMap"></a>Java源码之ConcurrentHashMap</h1><h2 id="1、带着问题看源码"><a href="#1、带着问题看源码" class="headerlink" title="1、带着问题看源码"></a>1、带着问题看源码</h2><p>Q1：ConcurrentHashMap为什么是线程安全的？</p><p>Q2：JDK1.7和1.8的ConcurrentHashMap有什么不同？</p><p>Q3：动态扩容策略是什么，如何多线程扩容的？</p><h2 id="2、数据存储结构"><a href="#2、数据存储结构" class="headerlink" title="2、数据存储结构"></a>2、数据存储结构</h2><p>先看JDK1.8的，数组 + 链表 + 红黑树，为了保证扩容时的线程安全，还增加了一种转移节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容转移时的最小数组分组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for 转移节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for 红黑树根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="comment">// CPU核数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// volatile 修饰哈希表，具有线程可见性</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table initialization and resizing control.</span></span><br><span class="line"><span class="comment"> * -1: 初始化</span></span><br><span class="line"><span class="comment"> * -(1 + 正在进行resize的线程数)，与-1区别开</span></span><br><span class="line"><span class="comment"> * 0: 默认状态</span></span><br><span class="line"><span class="comment"> * 在初始化之后，该值表示下一次扩容阈值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 转移下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">// 转移节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h2><p>自旋 + cas + 双重check</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化 table，通过对 sizeCtl 的变量赋值来保证数组只能被初始化一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 通过自旋保证初始化成功</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于0代表有线程正在初始化，释放当前CPU的调度权</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 赋值保证当前只有一个线程在初始化，-1 代表当前只有一个线程能初始化</span></span><br><span class="line">        <span class="comment">// 保证了数组的初始化的安全性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 可能执行到这里的时候，table已经不为空了，这里是双重check</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 进行初始化</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 负载因子0.75</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、查询元素"><a href="#3、查询元素" class="headerlink" title="3、查询元素"></a>3、查询元素</h2><p>不需要加锁，因为哈希表的节点用volatile修饰了，多线程之间具有可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hashcode</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 不是空的数组 &amp;&amp; 并且当前索引的槽点数据不是空的</span></span><br><span class="line">    <span class="comment">// 否则该key对应的值不存在，返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 槽点第一个值和key相等，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是红黑树或者转移节点，使用对应的find方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果是链表，遍历查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、添加元素"><a href="#4、添加元素" class="headerlink" title="4、添加元素"></a>4、添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HashMap时可以put null的，ConcurrentHashMap不可以</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16) &amp; HASH_BITS(0x7fffffff)，多&amp;了HASHBITS</span></span><br><span class="line">    <span class="comment">// hash的负在ConcurrentHashMap中有特殊意义表示在扩容或者是树节点</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当对应的哈希槽为转移节点时陷入自旋，等待扩容完成</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 哈希表为空，初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 如果当前索引位置为空，直接插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//cas在位置i创建新的元素，当位置i为空时，即能创建成功，结束自旋 </span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前哈希槽是转移节点，表示该槽点正在扩容，就会一直等待扩容完成</span></span><br><span class="line">        <span class="comment">// 转移节点的hash值为MOVED=-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 哈希槽上有值，即发生冲突</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁定当前哈希槽，其余线程不能操作，保证了安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// key已存在</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 记录旧值</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 覆盖值</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 把新增的元素添加到链表的末尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树，这里没有使用TreeNode,使用的是TreeBin，TreeNode只是红黑树的一个节点</span></span><br><span class="line">                    <span class="comment">// TreeBin持有红黑树的引用，并且会对其加锁，保证其操作的线程安全</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 在putTreeVal方法里面，在给红黑树重新着色旋转的时候，会锁住红黑树的根节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 记录旧值</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="comment">// 覆盖值</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// binCount不为0</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 链表是否需要转化成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 旧值不为空，返回旧值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哈希槽数 +1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、动态扩容"><a href="#5、动态扩容" class="headerlink" title="5、动态扩容"></a>5、动态扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增元素时，也就是在调用 putVal 方法后，为了通用，增加了check入参，用于指定是否可能会出现扩容的情况</span></span><br><span class="line"><span class="comment">//check &gt;= 0 即为可能出现扩容的情况，例如 putVal方法中的调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 类似LongAdder的计数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">      <span class="comment">// 检查当前哈希表元素个数s是否达到扩容阈值sizeCtl ，扩容时sizeCtl为负数，依旧成立，同时还得满足数组非空且数组长度不能大于允许的数组最大长度这两个条件</span></span><br><span class="line">        <span class="comment">// 这个while循环除了判断是否达到阈值从而进行扩容操作之外还有一个作用就是当一条线程完成自己的迁移任务后，如果集合还在扩容，则会继续循环，帮助扩容，申请后面的迁移任务</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据length得到一个标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// sc &lt; 0说明集合正在扩容当中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 sc 的高 16 位不等于标识符（说明sizeCtl变化了）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 1（当一个扩容线程结束，就会将sc减一，全部扩容线程结束，sc就等于rs+1 ）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + MAX_RESIZERS（65535，即低16全为1，扩容线程数已经达到最大）</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></span><br><span class="line">                <span class="comment">// 结束循环 </span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 扩容还未结束，并且允许扩容线程加入，扩容线程数+1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将sc更新：标识符左移16位 然后+2. 也就是变成一个负数。高16位是标识符，低16位初始是2（即为一个线程），后面扩容时会根据线程是否为这个值来确定是否为最后一个线程  </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新sizeCtl为负数后，开始扩容</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容状态下其他线程对集合进行插入、修改、删除、合并、compute等操作时遇到 ForwardingNode 节点会调用该帮助扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">//此处的 while 循环是上面 addCount 方法的部分逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tab：原数组，nextTab：新数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 将 length / 8 然后除以 CPU核心数。如果得到的结果小于MIN_TRANSFER_STRIDE（16），那么就等于16。</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 如果新数组为空，初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容两倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">// 扩容失败， sizeCtl设为INT_MAX</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 表示转移时的下标边界</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 推进标识</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 标识是否完成</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 自旋，i 的值会从原数组划分的子区域的最大值开始，慢慢递减到 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）</span></span><br><span class="line">            <span class="comment">// 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。</span></span><br><span class="line">            <span class="comment">// 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 这里的目的是：1. 当一个线程进入时，会选取最新的转移下标。2. 当一个线程处理完自己的区间时，如果还有剩余区间的没有别的线程处理。再次获取区间。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CAS 修改 transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其中一个条件满足说明拷贝结束了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>; <span class="comment">// 置空</span></span><br><span class="line">                table = nextTab;  <span class="comment">// 更新哈希表</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 更新阈值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试将 sc -1. 表示这个线程结束扩容了，将 sc 的低 16 位减一。</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果sc - 2不等于标识符左移 16 位。如果相等了，说明没有线程在帮助扩容了,也就是说，扩容结束了。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 不相等，说明还有其他扩容线程，当前线程结束方法。</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>; <span class="comment">// 相等，标记结束</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原哈希表位置i为空，用fwd转移节点占位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 为转移节点，说明别的线程已经处理过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点加锁。加锁是为了防止 putVal 的时候向链表插入数据</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 判断 i 下标处的桶节点是否和 f 相同</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn; <span class="comment">// low node, high node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f; <span class="comment">// 记录上一个节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果最后更新的runBit为0，设为low节点，为1则设为high节点</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 再次循环，生成两个链表，lastRun作为停止条件，为了避免多余的新建节点连接</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 在新数组相应位置上放置拷贝的值，原理和hashmap一样</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 在旧数组位置上放上 ForwardingNode 节点</span></span><br><span class="line">                        <span class="comment">// put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数据了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树的拷贝，同 HashMap 的内容</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                      TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                          <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                          TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                            (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                          <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                              lo = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                              loTail.next = p;</span><br><span class="line">                            loTail = p;</span><br><span class="line">                            ++lc;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                              hi = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                              hiTail.next = p;</span><br><span class="line">                            hiTail = p;</span><br><span class="line">                            ++hc;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">// 在旧数组位置上放上 ForwardingNode 节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完之后觉得十分巧妙，引入一个转移节点，resize扩容的并发线程数与ConcurrentHashMap的操作频繁度相关，越频繁，并发扩容线程数越多，非常合理极致地利用CPU资源。</p><h2 id="6、对比JDK1-7"><a href="#6、对比JDK1-7" class="headerlink" title="6、对比JDK1.7"></a>6、对比JDK1.7</h2><h3 id="6-1、数据存储结构"><a href="#6-1、数据存储结构" class="headerlink" title="6.1、数据存储结构"></a>6.1、数据存储结构</h3><p>数组（Segment） + 数组（HashEntry） + 链表（HashEntry节点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认并发度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 分段锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h3 id="6-2、查询元素"><a href="#6-2、查询元素" class="headerlink" title="6.2、查询元素"></a>6.2、查询元素</h3><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 计算hash值，对应具体的Segment</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历元素，找到了就返回</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3、添加元素"><a href="#6-3、添加元素" class="headerlink" title="6.3、添加元素"></a>6.3、添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key); <span class="comment">// 根据key找Segment</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value); <span class="comment">// put时锁定。如果当前没这条数据，则会返回新创建的HashEntry，否则为空</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index); <span class="comment">// 返回数组中对应位置的元素（链表头部）</span></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// 节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// key是否相等，是否进行覆盖</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果数组对应位置为空</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) <span class="comment">// 非空，则表示为新创建的值，头插法</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first); <span class="comment">// 否则创建一个</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 超过了容量阈值，但没达到最大限制，则扩容table</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node); <span class="comment">// 直接用新的node，替换掉旧的first node</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash); <span class="comment">// 返回与hash对应的数组内容</span></span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;<span class="comment">// 数组对应位置的链表头部</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;<span class="comment">// 非阻塞获取锁</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123; <span class="comment">// 如果头节点为空，创建新node，作为链表头部</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key)) <span class="comment">// 存在，则比较是否为同一个key</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 存在，且链表头部和当前插入的值非同，则比较。</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123; <span class="comment">// 最多tryLock次数，超过次数，就阻塞</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4、动态扩容"><a href="#6-4、动态扩容" class="headerlink" title="6.4、动态扩容"></a>6.4、动态扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历原数组，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 该位置处只有一个元素</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 与1.8类似</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask; <span class="comment">// 相当于 i 或 i + n </span></span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    <span class="comment">// 头插法</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>Q1：ConcurrentHashMap为什么是线程安全的？</p><p>Q2：JDK1.7和1.8的ConcurrentHashMap有什么不同？</p><p>1、锁粒度和使用锁</p><ul><li>JDK1.7的ConcurrentHashMap通过分段锁机制减小锁的粒度，使用可重入锁ReentrantLock保证线程安全</li><li>JDK1.8进一步缩小了锁的粒度至哈希槽，使用CAS机制和Synchronized（锁优化）保证线程安全</li></ul><p>2、并行度控制</p><ul><li>JDK1.7通过分段锁的个数控制并发，默认是16</li><li>JDK1.8通过转移节点，扩容时并行度可以根据容器操作的频率进行动态的调整</li></ul><p>3、数据结构</p><p>​    和HashMap一样，JDK1.8增加了红黑树和链表的转换，主要是兜底哈希函数效果不好的时候，查询性能至少能维持在O(logn)</p><p>Q3：动态扩容策略是什么，如何多线程扩容的？</p><p>​    扩容至原来的两倍，对原哈希表的数据进行重新散列</p><p>​    转移节点和sizeCtl标识十分重要，当一个哈希槽的节点为转移节点时，put操作的线程会进行等待或帮助扩容，每个线程领取哈希表中的一段进行转移，转移完成后领取剩余断，扩容结束后更新sizeCtl，从而根据put的频繁程度并行度也会相应地动态变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java源码之ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#Java源码之ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;Java源码之ConcurrentHashMap&quot;&gt;&lt;/a&gt;Java源码之Concurr
      
    
    </summary>
    
    
    
      <category term="Java源码" scheme="https://github.com/linlinnn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之HashMap</title>
    <link href="https://github.com/linlinnn/2020/02/26/Java%E6%BA%90%E7%A0%81%E4%B9%8BHashMap/"/>
    <id>https://github.com/linlinnn/2020/02/26/Java%E6%BA%90%E7%A0%81%E4%B9%8BHashMap/</id>
    <published>2020-02-26T07:51:41.426Z</published>
    <updated>2020-02-27T16:03:15.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java源码之HashMap"><a href="#Java源码之HashMap" class="headerlink" title="Java源码之HashMap"></a>Java源码之HashMap</h1><h2 id="1、带着问题看源码"><a href="#1、带着问题看源码" class="headerlink" title="1、带着问题看源码"></a>1、带着问题看源码</h2><p>Q1：江湖规矩，请问HashMap是线程安全的吗？为什么线程不安全？</p><p>Q2：JDK1.7和1.8的HashMap有哪些区别？</p><p>Q3：如何解决Hash冲突解决？</p><p>Q4：动态扩容的策略是什么？</p><h2 id="2、数据存储结构"><a href="#2、数据存储结构" class="headerlink" title="2、数据存储结构"></a>2、数据存储结构</h2><p>先从1.8的看起，HashMap底层的数据结构是数组+链表+红黑树</p><p>显然最突出就是一个链表和红黑树的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的HashMap的空间大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// hashMap最大的空间大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// HashMap默认负载因子，负载因子越小，hash冲突机率越低，至于为什么，看完下面源码就知道了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表长度大于等于8时，链表转化成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树大小小于等于6时，红黑树转化成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 当数组容量大于 64 时，链表才会转化成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 临界值（超过这个值则开始扩容）</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// HashMap 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">// 红黑树的节点</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h2><p>有四种初始化方法，指定初始容量和负载因子，指定初始容量，无参，指定数据集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 边界值判断</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 根据初始容量计算扩容临界值，&gt;=initialCapacity的2的最小的幂次方</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意这里没有32位的移动，因为最大容量MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、查询元素"><a href="#4、查询元素" class="headerlink" title="4、查询元素"></a>4、查询元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab:哈希表，first:hash对应哈希槽，n:哈希表的长度，</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个元素是不是想要查询的？是的话直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 遍历查询</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 红黑树，BST查询</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表，遍历查询</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道元素时怎样查的了，那么添加元素肯定就要与之对应起来。</p><h2 id="5、添加元素"><a href="#5、添加元素" class="headerlink" title="5、添加元素"></a>5、添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">// key为null返回0，反则hash码后与自身高16位进行异或</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab:哈希表，n:哈希表的长度，i:散列后落到哈希表的索引，p：索引i对应的节点</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果哈希表为空，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果节点为空，直接设为新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 旧节点和新节点哈希值和key都相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 节点p是一个红黑树节点，按照红黑树的方式设置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历链表至末尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 新节点插入到链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度超过阈值8的话，转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 循环过程中遇到一个与新节点相同的节点，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e不为空代表有一个节点哈希值和key都和新节点相同</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 如果不是putIfAbsent或者旧值为空，替换为新值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 哈希表超过扩容阈值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​       红黑树是一种平衡二叉查找树，查询效率为<code>O(logn)</code></p><p>​    为什么大于等于8要进行链表到红黑树的转换，注释上大佬有说，因为正常情况下根据泊松分布，有8个哈希值冲突的概率是0.00000006，更多的话就小于千万分之一，一般根本不会发生，之后是小弟的认知，以此推论如果发生了的话就是散列函数出了问题或者是数据非常特殊导致不断发生哈希冲突，在这种情况下，红黑树作为一种查询性能较高的数据结构作为兜底，维持到O(logn)</p></blockquote><h2 id="6、动态扩容"><a href="#6、动态扩容" class="headerlink" title="6、动态扩容"></a>6、动态扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// oldCapacity:旧哈希表的大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// newCapacity:新哈希表的大小，newThreshold:新的扩容阈值，大佬是不喜欢长命名么。。</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧哈希表大小 &gt;= 2^30，直接到顶INT_MAX</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新哈希表大小 * 2 &lt; 2^30 且 旧哈希表大小 &gt;= 16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容阈值 * 2</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧哈希表大小为0，旧扩容阈值&gt;0，初始化为旧扩容阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    <span class="comment">// 旧哈希表大小为0，旧扩容阈值为0，初始化为默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 16*0.75=12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新扩容阈值为0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor; <span class="comment">// 容量*负载因子</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 将旧的哈希表元素重新散列到新的哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 该哈希槽只有一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 该哈希槽内对应的是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 该哈希槽内对应的是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 位置不变的链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; </span><br><span class="line">                    <span class="comment">// 位置+oldCap的链表</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 为0则还在原位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 需要移动+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 位置不变的链表不为空，原位置指向头节点</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 位置+oldCap的链表不为空，原位置+oldCap指向头节点</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩容策略是当哈希表中的元素个数大于<code>哈希表大小 * 负载因子</code>，哈希表大小*2，乘2很好理解，因为保持了2的幂次方，可以看到扩容后需要对原来的元素进行重新散列，这个过程是非常消耗性能的。</li><li>负载因子默认为<code>0.75</code>，哈希表默认大小为<code>16</code>，当插入第13个元素时，哈希表扩容至32。</li><li>负载因子越大，空间利用率越高，哈希冲突可能性也越大，所以0.75是这两者考量之下折中的值，并且在这个情况下，哈希冲突同一位置超过8个的概率已经低于千万分之一了</li><li>hash函数：<code>hash &amp; (newCap - 1)</code>，即掩码多了一位1，那么要么还在原位置，要么移动原哈希表大小的位置（+oldCap）</li></ul><h2 id="7、对比JDK1-7"><a href="#7、对比JDK1-7" class="headerlink" title="7、对比JDK1.7"></a>7、对比JDK1.7</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享的空Map</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="comment">// table就是HashMap实际存储数组的地方</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        <span class="comment">// 数组初始化</span></span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果key为null，将这个entry放到table[0]中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1. 求key的hash值，进行了多次异或，由于边际效应并不高，1.8只对高16位异或一次</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的key已经存在，如果有，直接覆盖，put方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// key -&gt; value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的key，将此 entry 添加到链表中</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前HashMap大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，容量 * 2</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建元素</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头插法，将新值放到链表的表头，然后size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 新节点.next = e</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 如果之前的HashMap已经扩充到最大了，那么就将临界值threshold设置为最大的int值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 阈值计算</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>Q1：江湖规矩，请问HashMap是线程安全的吗？为什么线程不安全？</p><p>Q2：JDK1.7和1.8的HashMap有哪些区别？</p><p>​    Q1、Q2一起回答，当然是线程不安全的；</p><p>​    JDK1.7的HashMap添加元素发生哈希冲突时用的是头插法，即插入的元素作为头，这会使得扩容的时候链表逆序，此时多线程可能会产生循环链表，查询一个hash值对应这个循环链表而key又不存在的元素的时候就会陷入死循环中，JDK1.8使用尾插法（preserve order）避免了这种情况。</p><p>​    当然，JDK1.8的HashMap也是线程不安全的，最简单的一个栗子，<code>if (++size &gt; threshold)</code>，size是一个int类型的成员变量，没有原子性，很显然是线程不安全的，更糟糕的情况还有，如果两个哈希值相同，key不同的元素同时添加，可能会出现一个将另一个直接替换，就导致了数据的丢失。</p><p>​    JDK1.7和1.8的HashMap的区别从数据存储结构来看，1.8多了红黑树的结构，会在哈希表总数&gt;=64 且 同一哈希槽节点数&gt;=8的时候从链表转换为红黑树，红黑树节点&lt;=6时转换成链表，中间隔了个7可以起到一定的缓冲作用。</p><p>​    1.8还做了一些优化，如hash()只进行了一次异或操作</p><p>Q3：如何解决Hash冲突解决？</p><p>​    上面已经说了，一种是链表，一种是红黑树</p><p>Q4：动态扩容的策略是什么？</p><p>​    指定大小初始化时，哈希表的大小为&gt;=指定大小的2的幂次方</p><p>​    当size超过扩容阈值（哈希表大小 * 负载因子）时，扩容至原来的两倍，将旧的哈希表数据重新散列到新的哈希表</p><p>​    JDK1.8还有数据量小于64但某个哈希槽数据量&gt;=8时，也会进行扩容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java源码之HashMap&quot;&gt;&lt;a href=&quot;#Java源码之HashMap&quot; class=&quot;headerlink&quot; title=&quot;Java源码之HashMap&quot;&gt;&lt;/a&gt;Java源码之HashMap&lt;/h1&gt;&lt;h2 id=&quot;1、带着问题看源码&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Java源码" scheme="https://github.com/linlinnn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之LinkedList</title>
    <link href="https://github.com/linlinnn/2020/02/26/Java%E6%BA%90%E7%A0%81%E4%B9%8BLinkedList/"/>
    <id>https://github.com/linlinnn/2020/02/26/Java%E6%BA%90%E7%A0%81%E4%B9%8BLinkedList/</id>
    <published>2020-02-26T02:49:24.803Z</published>
    <updated>2020-02-26T07:40:41.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java源码之LinkedList"><a href="#Java源码之LinkedList" class="headerlink" title="Java源码之LinkedList"></a>Java源码之LinkedList</h1><h2 id="1、带着问题看源码"><a href="#1、带着问题看源码" class="headerlink" title="1、带着问题看源码"></a>1、带着问题看源码</h2><p>Q1：添加、删除、查找、遍历操作相应操作的原理是什么，时间复杂度是多少？</p><p>Q2：跟ArrayList的对比？</p><p>Q3：序列化机制？</p><h2 id="2、数据存储结构"><a href="#2、数据存储结构" class="headerlink" title="2、数据存储结构"></a>2、数据存储结构</h2><p>LinkedList的数据存储结构是一个双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 指向第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">// 指向最后一个节点</span></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 指向上一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>size</code>表示当前链表的节点数，显然可以根据<code>size</code>将链表分成两半，靠近首部就从<code>first</code>开始遍历，靠近尾部就从<code>last</code>开始遍历</p><h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h2><p>有两种初始化方法，无参初始化，指定数据集合初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、添加元素"><a href="#4、添加元素" class="headerlink" title="4、添加元素"></a>4、添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在尾部添加一个元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 最后一个节点为空，即first节点=last节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="comment">// 添加到最后一个节点的后面</span></span><br><span class="line">    <span class="keyword">else</span> l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index表示第一个元素插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界检查是否在[0,size]</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">  <span class="comment">// 添加元素集合长度为0，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ; <span class="comment">// 前驱节点、后继节点</span></span><br><span class="line">  <span class="comment">// 在链尾添加，前驱节点为last节点</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，后继节点为index位置所在的节点</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 遍历集合插入元素到前驱节点的后面</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 前驱节点为null,插入到链表首部</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="comment">// 否则，插入到前驱节点的后面</span></span><br><span class="line">        <span class="keyword">else</span> pred.next = newNode;</span><br><span class="line">        <span class="comment">// 更新前驱节点</span></span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 连接后继节点</span></span><br><span class="line">  <span class="comment">// 后继节点为空，即前驱节点为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，连接在一起</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 同步链表长度</span></span><br><span class="line">    size += numNew; </span><br><span class="line">    modCount++; <span class="comment">// 修改计数只+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表操作，边界情况需要仔细考虑，主要考虑头和尾，比如<code>addAll</code> 的逻辑如下</p><ol><li><p>找到index位置对应的前驱节点和后继节点</p><p>1.1. 插入到链表尾部，后继节点为null</p><p>1.2. 插入到链表头部，前驱节点为null</p><p>1.3. 插入到链表中间，后继节点为index节点</p></li><li><p>将元素集合依次连接在前驱节点的后面</p><p>需要考虑1.2这种情况，前驱节点为null，即最后一个新增元素为first节点，然后依次连接</p></li><li><p>最后一个新增元素与后继节点相连</p><p>需要考虑1.1这种情况，后继节点为null，即最后一个新增元素为last节点</p></li></ol><h2 id="5、删除元素"><a href="#5、删除元素" class="headerlink" title="5、删除元素"></a>5、删除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除头节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">  <span class="comment">// 更新头节点为下一个节点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 链表只剩一个节点，删除后，first = last = null</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 头节点的prev设为null</span></span><br><span class="line">    <span class="keyword">else</span> next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除最后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 更新头节点为上一个节点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 链表只剩一个节点，删除后，first = last = null</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 尾节点的next设为null</span></span><br><span class="line">    <span class="keyword">else</span> prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除一个非空节点</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"><span class="comment">// 和前驱节点断开，考虑删除是不是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和后继节点断开，考虑删除是不是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>; <span class="comment">// 此时该节点的prev、item、next都设为了null</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、查询元素"><a href="#6、查询元素" class="headerlink" title="6、查询元素"></a>6、查询元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// index位于链表的左半部分，从first开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、序列化机制"><a href="#7、序列化机制" class="headerlink" title="7、序列化机制"></a>7、序列化机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按顺序序列化数据</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据进行反序列化构建链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>Q1：添加、删除、查找、遍历操作相应操作的原理是什么，时间复杂度是多少？</p><p>​    添加/删除元素，时间复杂度与位置相关，越靠近头节点或者尾节点，则趋向或等于O(1)，最差就是在中间位置，需要遍历n/2的长度，查找同理；<strong>所以遍历需要注意的是要使用迭代器依次顺序遍历</strong>，否则如果使用下标随机访问，则每次都要从头节点或者尾结点遍历一遍，大大降低性能。</p><p>Q2：跟ArrayList的对比？</p><ul><li>一个是数组结构，一个是双向链表；</li><li>ArrayList添加数据空间不够时需要动态扩容，LinkedList只需要将数据串联起来</li><li>都可以进行随机访问，但是ArrayList才适合，性能比LinkedList高得多</li><li>不能笼统地认为插入删除就链表快，查询遍历就数组快，还要考虑具体的位置<ul><li>把数据插入到头部，LinkedList很快就找到位置并串联起来，但是ArrayList要将元素后移，所以LinkedList快，数据位置越靠近中间LinkedList效率就越差。</li><li>把数据插入到尾部，ArrayList需要分情况讨论，不需要扩容的情况下是效率是很高的，因为不用复制移动元素，相比而言LinkedList定位尾部很快，不过需要new对象和指针串连，效率慢了一点，删除同理</li><li>查询的话主要是LinkedList不适合随机访问，顺序访问的前提下两者相差不大，ArrayList稍稍占优</li></ul></li></ul><p>Q3：序列化机制？</p><p>​    双向链表方便于往前和往后遍历，不过也需要花费前驱节点、后继节点这些指针定位空间，而我们真正需要的只是具有顺序性的数据，所以序列化时免去了指针这些不必要的浪费，然后反序列化重新构建链表</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java源码之LinkedList&quot;&gt;&lt;a href=&quot;#Java源码之LinkedList&quot; class=&quot;headerlink&quot; title=&quot;Java源码之LinkedList&quot;&gt;&lt;/a&gt;Java源码之LinkedList&lt;/h1&gt;&lt;h2 id=&quot;1、带着问
      
    
    </summary>
    
    
    
      <category term="Java源码" scheme="https://github.com/linlinnn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java源码之ArrayList</title>
    <link href="https://github.com/linlinnn/2020/02/25/Java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/"/>
    <id>https://github.com/linlinnn/2020/02/25/Java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/</id>
    <published>2020-02-25T01:14:10.654Z</published>
    <updated>2020-03-03T15:40:42.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java源码之ArrayList"><a href="#Java源码之ArrayList" class="headerlink" title="Java源码之ArrayList"></a>Java源码之ArrayList</h1><h2 id="1、带着问题看源码"><a href="#1、带着问题看源码" class="headerlink" title="1、带着问题看源码"></a>1、带着问题看源码</h2><p>Q1：添加、查找、遍历操作最为普遍，相应操作的原理是什么，时间复杂度是多少？</p><p>Q2：如何进行动态扩展的？</p><p>Q3：序列化机制是怎样的？</p><h2 id="2、数据存储结构"><a href="#2、数据存储结构" class="headerlink" title="2、数据存储结构"></a>2、数据存储结构</h2><p>ArrayList在日常工作中非常常用，底层结构就是一个数组</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/02/25/Java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/ArrayList.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>1、<code>DEFAULT_CAPACITY</code>，初始大小为10</p><p>2、<code>EMPTY_ELEMENTDATA</code> 和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 的区别在于添加第一个元素时的扩容策略</p><p>3、<code>elementData</code>使用<code>transient</code>修饰，比如一个100万大小的数组，只存储了100个数据，那么只序列化这100个就好了，避免浪费不必要的资源，使用<code>writeObject</code>和<code>readObject</code>进行序列化</p><h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h2><p>有三种初始化方法：指定大小初始化，无参初始化，指定数据集合初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指定大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 返回静态的空数组EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始大小为负数，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回静态的空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在添加第一个元素后大小才为10</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">      <span class="comment">// 如果集合元素类型不是Object，转换成Object类型，Q4：为什么？</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回静态的空数组EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q4的测试代码如下，转换是为了防止数组元素赋值时发生类型错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello,ArrayList"</span>);</span><br><span class="line"></span><br><span class="line">Object[] arr = list.toArray();</span><br><span class="line">System.out.println(arr.getClass().getSimpleName()); <span class="comment">// String[]</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Object();<span class="comment">// java.lang.ArrayStoreException</span></span><br></pre></td></tr></table></figure><h2 id="4、添加元素"><a href="#4、添加元素" class="headerlink" title="4、添加元素"></a>4、添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保数组容量大小，不够时执行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是静态空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，在minCapacity和默认大小10取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前数组大小小于期望大小，数组需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="comment">// 扩容加上原来的一半大小，即原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 加上一半还是不够大的话就直接扩至期望大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">// 准备扩容大小超过的INT_MAX - 8</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 为负时说明超出了INT的范围，抛出OutOfMemoryError异常</span></span><br><span class="line">        <span class="comment">// 否则MAX_ARRAY_SIZE刚好则为MAX_ARRAY_SIZE，还不够就INT_MAX</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将原数组拷贝到新的数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、删除元素"><a href="#5、删除元素" class="headerlink" title="5、删除元素"></a>5、删除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组边界检查，只对上限做了检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"><span class="comment">// 修改计数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"><span class="comment">// 把删除的元素以后的元素向前移动</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Checks if the given index is in range. If not, throws an appropriate runtime exception.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里值得注意的是<code>rangeCheck</code>和<code>rangeCheckForAdd</code> 的区别，<strong>函数的意义决定了函数的职责边界，从而对应内部的实现</strong>，如<code>rangeCheck</code> 是get、remove、set方法操作已存在元素的，所以只检查上边界，下边界检查的职责交给数组的访问，而<code>rangeCheckForAdd</code> 是add、addAll操作未存在元素的，所以检查上下边界。</p><h2 id="6、迭代器的remove和ArrayList的remove"><a href="#6、迭代器的remove和ArrayList的remove" class="headerlink" title="6、迭代器的remove和ArrayList的remove"></a>6、迭代器的remove和ArrayList的remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 同步期望计数</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改计数和期望计数不相同，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修改计数+1，后续没有进行同步期望计数，在遍历过程中会抛出ConcurrentModificationException</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历删除元素时两种方法比较</p><p>通过迭代器Iterator#remove方法不会报错，而forEach调用至fastRemove由于没有同步期望计数，会抛出<code>ConcurrentModificationException</code> 所以这两个remove方法有一定的偏向性，即ArrayList的remove应该用于删除单个元素的场景</p><h2 id="7、序列化机制"><a href="#7、序列化机制" class="headerlink" title="7、序列化机制"></a>7、序列化机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 序列化non-static和non-transient的数据</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"><span class="comment">// Q5:为什么这里还要write一次size呢？</span></span><br><span class="line">  <span class="comment">// 这是为了版本兼容，老版本根据size这个成员变量去申请对应空间</span></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">capacity</span>)</span>;</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>Q1：添加、查找、遍历操作最为普遍，相应操作的原理是什么，时间复杂度是多少？</p><p>​    添加/删除操作，需要考虑具体的位置，在数组开头，需要移动元素，时间复杂度是O(n)，在数组尾部，时间复杂度是O(1)，遍历查找无序数组中的一个元素时间复杂度为O(n)</p><p>Q2：如何进行动态扩展的？</p><p>​    当数组空间不足时进行动态扩展，扩展到原数组的1.5倍大小，仍不够的话扩展到期望大小（这种情况是初始化大小为10时或者addAll时发生），最多扩展至INT_MAX</p><p>Q3：序列化机制是怎样的？</p><p>​    保存元素的element数组使用transient修饰，是避免序列化没有存储数据的空间提升性能，使用定制化的writeObject序列化和readObject反序列化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java源码之ArrayList&quot;&gt;&lt;a href=&quot;#Java源码之ArrayList&quot; class=&quot;headerlink&quot; title=&quot;Java源码之ArrayList&quot;&gt;&lt;/a&gt;Java源码之ArrayList&lt;/h1&gt;&lt;h2 id=&quot;1、带着问题看源码
      
    
    </summary>
    
    
    
      <category term="Java源码" scheme="https://github.com/linlinnn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展点加载机制</title>
    <link href="https://github.com/linlinnn/2020/01/12/dubbo%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <id>https://github.com/linlinnn/2020/01/12/dubbo%E6%89%A9%E5%B1%95%E7%82%B9/</id>
    <published>2020-01-11T16:23:25.855Z</published>
    <updated>2020-04-11T15:13:40.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo扩展点加载机制"><a href="#Dubbo扩展点加载机制" class="headerlink" title="Dubbo扩展点加载机制"></a>Dubbo扩展点加载机制</h2><h3 id="1、Java-SPI"><a href="#1、Java-SPI" class="headerlink" title="1、Java SPI"></a>1、Java SPI</h3><p>使用了策略模式，一个接口多种实现。只声明接口，具体的实现由程序之外的配置控制，用于具体实现的装配。</p><p>具体步骤如下：</p><p>（1）定义一个接口以及对应的方法</p><p>（2）编写接口的实现类</p><p>（3）在<code>META-INF/services/</code> 目录下，创建一个接口全限定名命名的文件</p><p>（4）文件内容为具体实现类的全限定名，如果有多个，则用分行符分隔</p><p>（5）在代码中通过<code>java.util.ServiceLoader</code> 来加载具体的实现类</p><h3 id="2、扩展点加载机制的改进"><a href="#2、扩展点加载机制的改进" class="headerlink" title="2、扩展点加载机制的改进"></a>2、扩展点加载机制的改进</h3><ol><li>初始化<ul><li>JDK SPI: 一次性实例化扩展点所有实现，初始化耗时，没有也加载浪费资源</li><li>Dubbo SPI: 加载配置文件中的类，并分为不同的种类缓存在内存中，不会立即全部初始化</li></ul></li><li>扩展点加载失败<ul><li>JDK SPI: 获取不到扩展的名称，不能打印正常的异常信息</li><li>Dubbo SPI: 抛出真实异常并打印日志，部分扩展点加载失败不会影响其他扩展点和整个框架的使用</li></ul></li><li>实现了IOC和AOP机制</li></ol><h3 id="3、扩展点的配置规范"><a href="#3、扩展点的配置规范" class="headerlink" title="3、扩展点的配置规范"></a>3、扩展点的配置规范</h3><table><thead><tr><th>规范名</th><th>规范说明</th></tr></thead><tbody><tr><td>SPI配置文件路径</td><td>META-INF/services/<br>META-INF/dubbo/<br>META-INF/dubbo/internal/<br>全路径类名</td></tr><tr><td>文件内容格式</td><td>key=value方式，多个用换行符分隔</td></tr></tbody></table><h3 id="4、扩展点的分类与缓存"><a href="#4、扩展点的分类与缓存" class="headerlink" title="4、扩展点的分类与缓存"></a>4、扩展点的分类与缓存</h3><p>Dubbo SPI</p><ul><li>Class缓存：Dubbo SPI获取扩展类时，先从缓存中读取。如果缓存中不存在，则加载配置文件，根据配置把Class缓存到内存中，不会直接初始化</li><li>实例缓存：基于性能考虑，Dubbo框架不仅会缓存Class，也会缓存Class实例化对象。先从缓存中读取，如果缓存中不存在，则重新加载并缓存起来，按需实例化并缓存</li></ul><p>扩展类种类</p><ul><li>普通扩展类</li><li>包装扩展类：Wrapper类没有具体的实现，只是做了通用逻辑的抽象，在构造方法中传入一个具体的扩展接口的实现</li><li>自适应扩展类：一个扩展接口有多种实现类，具体实现哪个实现类可以不写死在配置或代码中，在运行时，通过传入URL中的某些参数动态来确定。自适应特性<code>@Adaptive</code></li><li>其他缓存</li></ul><p>自适应和自动激活的区别？</p><p><code>isAssignableFrom</code> 和 <code>instanceof</code> 的区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(子类.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">子类实例 <span class="title">instanceof</span> 父类类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo扩展点加载机制&quot;&gt;&lt;a href=&quot;#Dubbo扩展点加载机制&quot; class=&quot;headerlink&quot; title=&quot;Dubbo扩展点加载机制&quot;&gt;&lt;/a&gt;Dubbo扩展点加载机制&lt;/h2&gt;&lt;h3 id=&quot;1、Java-SPI&quot;&gt;&lt;a href=&quot;#1、J
      
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="https://github.com/linlinnn/tags/Dubbo/"/>
    
  </entry>
  
</feed>
